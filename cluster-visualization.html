<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>User Cluster Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Inter', 'Segoe UI', Roboto, -apple-system, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 30px;
        }
        .chart-container {
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            padding: 25px;
            margin-bottom: 30px;
            background-color: #fff;
            transition: all 0.3s ease;
        }
        .chart-container:hover {
            box-shadow: 0 6px 16px rgba(0,0,0,0.12);
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 25px;
            padding: 15px;
            background-color: #f0f2f5;
            border-radius: 8px;
        }
        .controls label {
            font-weight: 600;
            margin-right: 8px;
        }
        .controls select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ddd;
            background-color: white;
            font-size: 14px;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            margin-top: 15px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 6px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 8px;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: #f0f2f5;
            transition: all 0.2s;
        }
        .legend-item:hover {
            background-color: #e6e8eb;
        }
        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .cluster-info {
            margin-top: 25px;
            max-height: 350px;
            overflow-y: auto;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }
        .tooltip {
            position: absolute;
            background: #fff;
            border: none;
            padding: 12px;
            border-radius: 6px;
            pointer-events: none;
            font-size: 14px;
            box-shadow: 0 3px 14px rgba(0,0,0,0.15);
            max-width: 280px;
            z-index: 1000;
            transition: opacity 0.2s;
        }
        .tooltip h4 {
            margin-top: 0;
            margin-bottom: 8px;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .tooltip p {
            margin: 5px 0;
        }
        .user-details {
            padding: 25px;
            margin-top: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            background-color: #fff;
            display: none;
            animation: fadeIn 0.3s;
        }
        .preference-form {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #444;
        }
        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        .checkbox-group div {
            display: flex;
            align-items: center;
        }
        .checkbox-group label {
            font-weight: normal;
            margin-left: 5px;
            cursor: pointer;
        }
        button {
            padding: 10px 18px;
            background-color: #4a90e2;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #3a7bc8;
        }
        .tabs {
            display: flex;
            margin-bottom: 25px;
            border-bottom: 1px solid #ddd;
        }
        .tab {
            padding: 12px 24px;
            cursor: pointer;
            margin-right: 5px;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            background-color: #f5f5f5;
            transition: all 0.2s;
        }
        .tab.active {
            background-color: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
            font-weight: 600;
        }
        .tab:hover:not(.active) {
            background-color: #e9ecef;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .status-message {
            padding: 15px;
            margin: 15px 0;
            border-radius: 6px;
            background-color: #e6f7ff;
            border-left: 4px solid #1890ff;
            animation: fadeIn 0.3s;
        }
        
        .error-message {
            background-color: #fff2f0;
            border-left: 4px solid #ff4d4f;
        }
        
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .chart-header h3 {
            margin: 0;
        }
        
        .control-group {
            padding: 8px;
            border-radius: 6px;
        }
        
        .custom-cluster-form {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-top: 20px;
        }
        
        .cluster-criteria, .custom-clusters-list {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        
        .criteria-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .criteria-row select, .criteria-row input {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ddd;
            background-color: white;
        }
        
        .custom-cluster-item {
            background-color: #f9f9f9;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #4a90e2;
        }
        
        .custom-cluster-item h4 {
            margin-top: 0;
            margin-bottom: 10px;
        }
        
        .custom-cluster-item .actions {
            margin-top: 10px;
        }
        
        .criteria-badge {
            display: inline-block;
            background-color: #e6f7ff;
            padding: 4px 8px;
            border-radius: 4px;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 13px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .interest-cluster-form {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            margin-bottom: 20px;
        }
        
        .interest-checklist {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 10px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 6px;
        }
        
        .interest-category {
            background-color: #fff;
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #eee;
        }
        
        .interest-category h4 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 14px;
            color: #444;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        
        .checkbox-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .checkbox-grid label {
            display: flex;
            align-items: center;
            font-size: 14px;
        }
        
        .checkbox-grid input[type="checkbox"] {
            margin-right: 6px;
        }
        
        .clustering-option {
            margin-bottom: 10px;
        }
        
        .clustering-option label {
            display: flex;
            align-items: center;
        }
        
        .clustering-option input[type="radio"] {
            margin-right: 8px;
        }
        
        .cluster-rename-entry {
            display: flex;
            align-items: center;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #f9f9f9;
            border-radius: 6px;
        }
        
        .cluster-rename-entry .cluster-info {
            flex: 1;
            margin-right: 15px;
        }
        
        .cluster-rename-entry input[type="text"] {
            padding: 8px;
            flex: 1;
            max-width: 250px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        .cluster-rename-entry button {
            margin-left: 10px;
            white-space: nowrap;
        }
        
        .rename-clusters-form {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        
        .cluster-rename-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 6px;
        }
        
        .sub-tabs {
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        
        .sub-tab {
            padding: 10px 20px;
            font-size: 14px;
        }
        
        .subtab-content {
            display: none;
        }
        
        .subtab-content.active {
            display: block;
            animation: fadeIn 0.3s;
        }

        .feedback-history {
            margin-top: 25px;
            max-height: 400px;
            overflow-y: auto;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
        }

        .feedback-item {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .feedback-item .user-input {
            padding: 10px;
            border-left: 3px solid #4a90e2;
            background-color: #f8f9fa;
            margin-bottom: 10px;
        }

        .feedback-item .system-response {
            padding: 10px;
            border-left: 3px solid #42b983;
            background-color: #f8f9fa;
            margin-bottom: 10px;
        }

        .feedback-item .user-feedback {
            display: flex;
            align-items: center;
            padding: 5px 10px;
            background-color: #f0f2f5;
            border-radius: 4px;
        }

        .feedback-item .feedback-rating {
            margin-right: 10px;
            font-weight: bold;
        }

        .feedback-item .feedback-date {
            margin-left: auto;
            font-size: 12px;
            color: #666;
        }

        .feedback-positive {
            color: #42b983;
        }

        .feedback-negative {
            color: #e75c3c;
        }

        .feedback-neutral {
            color: #f39c12;
        }
        
        /* Similar Topics Styles */
        .similar-topics-list {
            margin-top: 25px;
            max-height: 500px;
            overflow-y: auto;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
        }
        
        .topic-item {
            margin-bottom: 15px;
            padding: 15px;
            background-color: #fff;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            border-left: 3px solid #4a90e2;
            transition: all 0.2s ease;
        }
        
        .topic-item:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        
        .topic-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        
        .topic-user {
            font-weight: bold;
            color: #4a90e2;
        }
        
        .topic-date {
            color: #666;
            font-size: 0.9em;
        }
        
        .topic-name {
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .topic-query {
            color: #333;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-style: italic;
        }
        
        #fetch-topics-btn {
            margin-left: 10px;
        }
        
        #cluster-preferences {
            margin: 20px 0;
            background-color: #e6f7ff;
        }
        
        .preference-tag {
            display: inline-block;
            background-color: #f0f2f5;
            padding: 5px 10px;
            margin-right: 8px;
            margin-bottom: 8px;
            border-radius: 20px;
            font-size: 14px;
        }
        
        .no-topics-message {
            padding: 20px;
            text-align: center;
            background-color: #f9f9f9;
            border-radius: 8px;
            margin-top: 20px;
            color: #666;
        }
        
        .no-topics-message.error-message {
            background-color: #fff2f0;
            border-left: 4px solid #ff4d4f;
            text-align: left;
            color: #333;
        }
        
        .no-topics-message.error-message ul {
            margin-top: 5px;
            margin-left: 20px;
            margin-bottom: 10px;
        }
        
        .topics-title {
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .topics-title h4 {
            margin: 0;
            color: #444;
        }
        
        /* Topic Analysis Styles */
        .topic-analysis-controls {
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }
        
        .topic-analysis-results {
            margin-top: 25px;
        }
        
        .topic-stats-overview, .topic-cluster-distribution, .topic-heatmap, .topic-insights {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            margin-bottom: 20px;
        }
        
        .topic-stat-card {
            display: inline-block;
            background-color: #f0f2f5;
            border-left: 4px solid #4a90e2;
            padding: 15px;
            margin: 10px;
            border-radius: 6px;
            min-width: 200px;
        }
        
        .topic-stat-card h4 {
            margin: 0 0 10px 0;
            color: #4a90e2;
        }
        
        .topic-stat-card .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        
        .topic-stat-card .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        
        .heatmap-cell {
            stroke: #fff;
            stroke-width: 1;
            cursor: pointer;
        }
        
        .heatmap-label {
            font-size: 12px;
            text-anchor: middle;
            dominant-baseline: central;
        }
        
        .cluster-label-axis {
            font-size: 11px;
            text-anchor: end;
        }
        
        .topic-label-axis {
            font-size: 11px;
            text-anchor: start;
        }
        
        .insight-item {
            background-color: #f8f9fa;
            border-left: 4px solid #42b983;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 6px;
        }
        
        .insight-item h4 {
            margin: 0 0 10px 0;
            color: #42b983;
        }
        
        .topic-filter-applied {
            background-color: #e6f7ff;
            border-left: 4px solid #1890ff;
            padding: 10px 15px;
            border-radius: 6px;
            margin-bottom: 15px;
        }
        
        .topic-filter-applied .filter-info {
            font-weight: bold;
            color: #1890ff;
        }
        
        .topic-filter-applied .clear-filter {
            margin-left: 10px;
            font-size: 12px;
            text-decoration: underline;
            cursor: pointer;
        }
        
        .topic-distribution-bar {
            background-color: #4a90e2;
            height: 20px;
            margin: 5px 0;
            border-radius: 3px;
            transition: all 0.3s ease;
        }
        
        .topic-distribution-bar:hover {
            background-color: #3a7bc8;
        }
        
        .distribution-item {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 6px;
        }
        
        .distribution-item .topic-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .distribution-item .usage-count {
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>User Cluster Visualization</h1>
        
        <div class="tabs">
            <div class="tab active" data-tab="visualization">Cluster Visualization</div>
            <div class="tab" data-tab="userPreferences">Update User Preferences</div>
            <div class="tab" data-tab="clusterManagement">Cluster Management</div>
            <div class="tab" data-tab="similarTopics">Similar User Topics</div>
            <div class="tab" data-tab="topicAnalysis">Topic Analysis</div>
        </div>
        
        <div id="visualization" class="tab-content active">
            <div class="controls">
                <div class="control-group">
                    <label for="x-axis">X Axis:</label>
                    <select id="x-axis">
                        <option value="technical_depth" selected>Technical Depth</option>
                        <option value="visual_learning">Visual Learning</option>
                        <option value="practical_examples">Practical Examples</option>
                        <option value="age">Age</option>
                        <option value="interest_science">Interest: Science</option>
                        <option value="interest_technology">Interest: Technology</option>
                        <option value="interest_sports">Interest: Sports</option>
                        <option value="interest_art">Interest: Art</option>
                        <option value="interest_music">Interest: Music</option>
                        <option value="professional_level">Professional Level</option>
                        <option value="avg_feedback_rating">Average Feedback Rating</option>
                        <option value="feedback_count">Feedback Count</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="y-axis">Y Axis:</label>
                    <select id="y-axis">
                        <option value="technical_depth">Technical Depth</option>
                        <option value="visual_learning" selected>Visual Learning</option>
                        <option value="practical_examples">Practical Examples</option>
                        <option value="age">Age</option>
                        <option value="interest_science">Interest: Science</option>
                        <option value="interest_technology">Interest: Technology</option>
                        <option value="interest_sports">Interest: Sports</option>
                        <option value="interest_art">Interest: Art</option>
                        <option value="interest_music">Interest: Music</option>
                        <option value="professional_level">Professional Level</option>
                        <option value="avg_feedback_rating">Average Feedback Rating</option>
                        <option value="feedback_count">Feedback Count</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="topic-filter">Filter by Topic:</label>
                    <select id="topic-filter">
                        <option value="">All Topics</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="min-usage">Min Usage:</label>
                    <input type="number" id="min-usage" min="1" max="50" value="1" style="width: 60px;">
                </div>
                
                <div class="control-group">
                    <button id="apply-dimensions" type="button">Apply Filters</button>
                    <button id="reset-filters" type="button">Reset</button>
                </div>
            </div>

            <div class="chart-container">
                <svg id="chart" width="800" height="500"></svg>
                <div class="legend" id="legend"></div>
                <div id="topic-filter-status" class="status-message" style="display: none;"></div>
            </div>
            
            <div class="cluster-info" id="cluster-info"></div>
        </div>
        
        <div id="userPreferences" class="tab-content">
            <h2>Update User Preferences</h2>
            <p>Select a user to update their preferences and potentially reassign them to a different cluster.</p>
            
            <div class="form-group">
                <label for="user-select">Select User:</label>
                <select id="user-select">
                    <option value="">-- Select User --</option>
                </select>
            </div>
            
            <div id="user-details" class="user-details">
                <h3>Current User Information</h3>
                <div id="current-info"></div>
                
                <h3>Conversation Feedback History</h3>
                <div id="feedback-history" class="feedback-history">
                    <p id="feedback-loading">Loading conversation feedback...</p>
                </div>
                
                <h3>Update Preferences</h3>
                <form id="preference-form" class="preference-form">
                    <div class="form-group">
                        <label for="technical-depth">Technical Depth (1-100):</label>
                        <input type="range" id="technical-depth" name="technical_depth" min="1" max="100" value="50" step="1">
                        <span id="technical-depth-value">50</span>
                    </div>
                    
                    <div class="form-group">
                        <label for="learning-style">Learning Style:</label>
                        <select id="learning-style" name="learning_style">
                            <option value="visual">Visual</option>
                            <option value="auditory">Auditory</option>
                            <option value="reading">Reading/Writing</option>
                            <option value="kinesthetic">Kinesthetic</option>
                        </select>
                    </div>
                    
                    <div class="form-group" style="grid-column: span 2;">
                        <label>Interests:</label>
                        <div class="checkbox-group" id="interests-group">
                            <!-- Will be populated dynamically -->
                        </div>
                    </div>
                    
                    <div class="form-group" style="grid-column: span 2;">
                        <label>Preferred Analogy Domains:</label>
                        <div class="checkbox-group" id="analogy-domains-group">
                            <!-- Will be populated dynamically -->
                        </div>
                    </div>
                    
                    <div class="form-group" style="grid-column: span 2;">
                        <button type="submit">Update Preferences</button>
                    </div>
                </form>
            </div>
        </div>
        
        <div id="clusterManagement" class="tab-content">
            <h2>Create Custom Clusters</h2>
            <p>Define custom clusters based on user preferences and attributes.</p>
            
            <div class="tabs sub-tabs">
                <div class="tab sub-tab active" data-subtab="criteria-based">Criteria-Based Clusters</div>
                <div class="tab sub-tab" data-subtab="interest-based">Interest-Based Clusters</div>
                <div class="tab sub-tab" data-subtab="rename-clusters">Rename Clusters</div>
            </div>
            
            <div id="criteria-based" class="subtab-content active">
                <div class="custom-cluster-form">
                    <div class="cluster-criteria">
                        <h3>Cluster Criteria</h3>
                        <p>Select the criteria that define your custom clusters.</p>
                        
                        <div class="form-group">
                            <label for="cluster-name">Cluster Name:</label>
                            <input type="text" id="cluster-name" placeholder="E.g., Technical Professionals">
                        </div>
                        
                        <div class="form-group">
                            <label>Primary Criteria:</label>
                            <div class="criteria-row">
                                <select id="primary-attribute">
                                    <option value="technical_depth">Technical Depth</option>
                                    <option value="learning_style">Learning Style</option>
                                    <option value="interests">Interests</option>
                                    <option value="age">Age</option>
                                    <option value="education_level">Education Level</option>
                                    <option value="occupation">Occupation</option>
                                </select>
                                
                                <select id="primary-operator">
                                    <option value="equals">Equals</option>
                                    <option value="greater_than">Greater Than</option>
                                    <option value="less_than">Less Than</option>
                                    <option value="contains">Contains</option>
                                </select>
                                
                                <input type="text" id="primary-value" placeholder="Value">
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label>Secondary Criteria (Optional):</label>
                            <div class="criteria-row">
                                <select id="secondary-attribute">
                                    <option value="">None</option>
                                    <option value="technical_depth">Technical Depth</option>
                                    <option value="learning_style">Learning Style</option>
                                    <option value="interests">Interests</option>
                                    <option value="age">Age</option>
                                    <option value="education_level">Education Level</option>
                                    <option value="occupation">Occupation</option>
                                </select>
                                
                                <select id="secondary-operator">
                                    <option value="equals">Equals</option>
                                    <option value="greater_than">Greater Than</option>
                                    <option value="less_than">Less Than</option>
                                    <option value="contains">Contains</option>
                                </select>
                                
                                <input type="text" id="secondary-value" placeholder="Value">
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <button id="create-cluster" type="button">Create Custom Cluster</button>
                        </div>
                    </div>
                    
                    <div class="custom-clusters-list">
                        <h3>Custom Clusters</h3>
                        <div id="custom-clusters">
                            <p>No custom clusters created yet.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="interest-based" class="subtab-content">
                <div class="interest-cluster-form">
                    <h3>Create Interest-Based Clusters</h3>
                    <p>Select multiple interests to create clusters of users who share these interests.</p>
                    
                    <div class="form-group">
                        <label for="interest-cluster-name">Cluster Name:</label>
                        <input type="text" id="interest-cluster-name" placeholder="E.g., Arts & Sports Enthusiasts">
                    </div>
                    
                    <div class="form-group">
                        <label>Select Interests:</label>
                        <div class="interest-checklist">
                            <div class="interest-category">
                                <h4>Arts & Culture</h4>
                                <div class="checkbox-grid">
                                    <label><input type="checkbox" name="interest" value="Art"> Art</label>
                                    <label><input type="checkbox" name="interest" value="Music"> Music</label>
                                    <label><input type="checkbox" name="interest" value="Literature"> Literature</label>
                                    <label><input type="checkbox" name="interest" value="Photography"> Photography</label>
                                    <label><input type="checkbox" name="interest" value="Writing"> Writing</label>
                                    <label><input type="checkbox" name="interest" value="Dancing"> Dancing</label>
                                </div>
                            </div>
                            
                            <div class="interest-category">
                                <h4>Sports & Fitness</h4>
                                <div class="checkbox-grid">
                                    <label><input type="checkbox" name="interest" value="Sports"> Sports</label>
                                    <label><input type="checkbox" name="interest" value="Basketball"> Basketball</label>
                                    <label><input type="checkbox" name="interest" value="Football"> Football</label>
                                    <label><input type="checkbox" name="interest" value="Soccer"> Soccer</label>
                                    <label><input type="checkbox" name="interest" value="Tennis"> Tennis</label>
                                    <label><input type="checkbox" name="interest" value="Fitness"> Fitness</label>
                                </div>
                            </div>
                            
                            <div class="interest-category">
                                <h4>Science & Technology</h4>
                                <div class="checkbox-grid">
                                    <label><input type="checkbox" name="interest" value="Science"> Science</label>
                                    <label><input type="checkbox" name="interest" value="Technology"> Technology</label>
                                    <label><input type="checkbox" name="interest" value="Programming"> Programming</label>
                                    <label><input type="checkbox" name="interest" value="Astronomy"> Astronomy</label>
                                    <label><input type="checkbox" name="interest" value="Physics"> Physics</label>
                                    <label><input type="checkbox" name="interest" value="Biology"> Biology</label>
                                </div>
                            </div>
                            
                            <div class="interest-category">
                                <h4>Lifestyle & Hobbies</h4>
                                <div class="checkbox-grid">
                                    <label><input type="checkbox" name="interest" value="Cooking"> Cooking</label>
                                    <label><input type="checkbox" name="interest" value="Travel"> Travel</label>
                                    <label><input type="checkbox" name="interest" value="Yoga"> Yoga</label>
                                    <label><input type="checkbox" name="interest" value="Meditation"> Meditation</label>
                                    <label><input type="checkbox" name="interest" value="Gaming"> Gaming</label>
                                    <label><input type="checkbox" name="interest" value="Movies"> Movies</label>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <div class="clustering-option">
                            <label>
                                <input type="radio" name="interest-matching" value="any" checked>
                                Match users with ANY of these interests
                            </label>
                        </div>
                        <div class="clustering-option">
                            <label>
                                <input type="radio" name="interest-matching" value="all">
                                Match users with ALL of these interests
                            </label>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <button id="create-interest-cluster" type="button">Create Interest Cluster</button>
                    </div>
                </div>
            </div>
            
            <div id="rename-clusters" class="subtab-content">
                <div class="rename-clusters-form">
                    <h3>Rename Existing Clusters</h3>
                    <p>Give descriptive names to existing system-generated clusters.</p>
                    
                    <div class="cluster-renaming-list">
                        <div class="form-group cluster-rename-controls">
                            <label for="cluster-rename-strategy">Naming Strategy:</label>
                            <select id="cluster-rename-strategy">
                                <option value="manual">Manual Naming</option>
                                <option value="auto-descriptive">Generate Descriptive Names</option>
                            </select>
                            <button id="apply-naming-strategy" type="button">Apply to All Clusters</button>
                        </div>
                        
                        <div id="cluster-naming-list">
                            <!-- Will be populated dynamically -->
                            <p>Loading clusters...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="similarTopics" class="tab-content">
            <h2>Similar User Topics</h2>
            <p>View recent chat topics from other users in your cluster.</p>
            
            <div class="form-group">
                <label for="similar-user-select">Select Your User ID:</label>
                <select id="similar-user-select">
                    <option value="">-- Select User --</option>
                </select>
                <button id="fetch-topics-btn" type="button">Fetch Topics</button>
            </div>
            
            <div id="cluster-preferences" class="status-message" style="display: none;">
                <h4>Your Cluster Information</h4>
                <div id="user-preferences-info"></div>
            </div>
            
            <div id="similar-topics-container" style="display: none;">
                <h3>Recent Topics from Users in Your Cluster</h3>
                <div id="similar-topics-list" class="similar-topics-list">
                    <p id="topics-loading">Select a user and click "Fetch Topics" to see topics from your cluster.</p>
                </div>
            </div>
        </div>
        
        <div id="topicAnalysis" class="tab-content">
            <h2>Topic Analysis</h2>
            <p>Analyze how different topics are distributed across user clusters and identify learning patterns.</p>
            
            <div class="topic-analysis-controls">
                <div class="control-group">
                    <label for="analysis-topic-select">Select Topic:</label>
                    <select id="analysis-topic-select">
                        <option value="">-- Select Topic --</option>
                    </select>
                    <button id="analyze-topic-btn" type="button">Analyze Topic</button>
                </div>
                
                <div class="control-group">
                    <button id="analyze-all-topics-btn" type="button">Analyze All Topics</button>
                    <button id="show-topic-heatmap-btn" type="button">Show Topic Heatmap</button>
                </div>
            </div>
            
            <div class="topic-analysis-results">
                <div class="topic-stats-overview" id="topic-stats-overview" style="display: none;">
                    <h3>Topic Statistics Overview</h3>
                    <div id="topic-stats-content"></div>
                </div>
                
                <div class="topic-cluster-distribution" id="topic-cluster-distribution" style="display: none;">
                    <h3>Topic Distribution Across Clusters</h3>
                    <svg id="topic-distribution-chart" width="800" height="400"></svg>
                </div>
                
                <div class="topic-heatmap" id="topic-heatmap" style="display: none;">
                    <h3>Cluster-Topic Heatmap</h3>
                    <div id="heatmap-container"></div>
                </div>
                
                <div class="topic-insights" id="topic-insights" style="display: none;">
                    <h3>Topic Insights</h3>
                    <div id="insights-content"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables to store our data
        let userData = [];
        let clusterData = [];
        let userFeedbackData = {}; // Store feedback data by user ID
        let topicsData = []; // Store topics data
        let topicDistribution = {}; // Store topic distribution data
        let currentTopicFilter = ''; // Current topic filter
        let isLoading = false;
        let colorScale; // Define colorScale globally
        
        // Predefined options for checkboxes
        const INTERESTS = [
          'Sports', 'Video Games', 'Movies', 'Books', 'Meditation',
          'Yoga', 'Technology', 'Cooking', 'Music', 'Travel',
          'Fitness', 'Art', 'Photography', 'Writing', 'Dancing',
          'Science', 'History', 'Languages', 'Philosophy', 'Astronomy'
        ];
        
        const ANALOGY_DOMAINS = [
          'Gaming', 'Sports', 'Movies', 'Technology', 'Cooking',
          'Everyday Life', 'Science', 'Historical Events', 'Nature',
          'Music', 'Architecture', 'Business'
        ];
        
        // Fetch data from your backend
        async function fetchData() {
            try {
                setLoading(true);
                showStatus('Fetching cluster data...');
                
                // Fetch the cluster data
                const clusterResponse = await fetch('http://localhost:3001/api/clusters');
                
                if (!clusterResponse.ok) {
                    throw new Error(`Failed to fetch clusters: ${clusterResponse.statusText}`);
                }
                
                clusterData = await clusterResponse.json();
                
                // The clusters endpoint returns {clusters: [...]} format
                if (clusterData.clusters) {
                    clusterData = clusterData.clusters;
                }
                
                // Try to fetch user data, but fall back to generating sample data if it fails
                try {
                    const userResponse = await fetch('http://localhost:3001/api/clusters/cluster-users');
                    if (userResponse.ok) {
                        const userResponseData = await userResponse.json();
                        userData = userResponseData.users || [];
                    } else {
                        throw new Error('User endpoint failed');
                    }
                } catch (userError) {
                    console.warn('Failed to fetch users from API, generating sample data:', userError);
                    userData = generateSampleUserData(clusterData);
                }
                
                // Fetch topics data
                await fetchTopicsData();
                
                console.log("Successfully fetched data from API:");
                console.log("Clusters:", clusterData);
                console.log("Users:", userData);
                console.log("Topics:", topicsData);
                
                if (clusterData.length === 0 || userData.length === 0) {
                    showStatus('No cluster data available. Please ensure your database has user clusters defined.', true);
                } else {
                    hideStatus();
                    // For each user, add cluster centroid values for visualization
                    userData = userData.map(user => {
                        const cluster = clusterData.find(c => c.id === user.cluster_id);
                        return {
                            ...user,
                            visual_learning: cluster ? cluster.centroid.visual_learning * 100 : 50,
                            practical_examples: cluster ? cluster.centroid.practical_examples * 100 : 70,
                            technical_depth: user.technical_depth || 50,
                            // Include additional clustering parameters
                            level_of_interest: user.level_of_interest || 'Unknown',
                            education_level: user.education_level || 'Unknown',
                            learning_style: user.learning_style || 'visual',
                            // Initialize feedback metrics with default values
                            avg_feedback_rating: 0,
                            feedback_count: 0
                        };
                    });
                    
                    // Fetch feedback data for each user
                    await fetchUserFeedbackForVisualization();
                    
                    renderVisualization();
                    populateUserSelect();
                    populateSimilarUserSelect(); // Also populate the similar user select dropdown
                    populateTopicSelects(); // Populate topic dropdowns
                }
            } catch (error) {
                console.error("Error fetching data:", error);
                showStatus(`Error loading data: ${error.message}`, true);
            } finally {
                setLoading(false);
            }
        }
        
        // Fetch topics data for filtering and analysis
        async function fetchTopicsData() {
            try {
                const response = await fetch('http://localhost:3001/api/clusters/topics');
                if (!response.ok) {
                    throw new Error(`Failed to fetch topics: ${response.statusText}`);
                }
                
                const data = await response.json();
                topicsData = data.topics || [];
                
                // Also fetch topic distribution
                const distributionResponse = await fetch('http://localhost:3001/api/clusters/topic-distribution');
                if (distributionResponse.ok) {
                    const distributionData = await distributionResponse.json();
                    topicDistribution = distributionData.distribution || {};
                }
                
                console.log('Topics fetched:', topicsData.length);
                console.log('Topic distribution:', topicDistribution);
            } catch (error) {
                console.error('Error fetching topics data:', error);
                topicsData = [];
                topicDistribution = {};
            }
        }
        
        // Fetch filtered data based on topic
        async function fetchFilteredData() {
            try {
                setLoading(true);
                
                const topic = document.getElementById('topic-filter').value;
                const minUsage = document.getElementById('min-usage').value;
                currentTopicFilter = topic;
                
                let url = 'http://localhost:3001/api/clusters/by-topic';
                const params = new URLSearchParams();
                
                if (topic) {
                    params.append('topic', topic);
                }
                if (minUsage && parseInt(minUsage) > 1) {
                    params.append('min_usage', minUsage);
                }
                
                if (params.toString()) {
                    url += '?' + params.toString();
                }
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch filtered clusters: ${response.statusText}`);
                }
                
                const data = await response.json();
                clusterData = data.clusters || [];
                
                // Update users based on topic filter
                const userParams = new URLSearchParams();
                if (topic) {
                    userParams.append('topic', topic);
                }
                
                const userUrl = 'http://localhost:3001/api/clusters/cluster-users' + (userParams.toString() ? '?' + userParams.toString() : '');
                const userResponse = await fetch(userUrl);
                
                if (userResponse.ok) {
                    const userData_response = await userResponse.json();
                    userData = userData_response.users || [];
                }
                
                // Show filter status
                if (topic || (minUsage && parseInt(minUsage) > 1)) {
                    const filterStatus = document.getElementById('topic-filter-status');
                    const topicName = topic || 'All Topics';
                    const usageText = minUsage && parseInt(minUsage) > 1 ? ` (min ${minUsage} uses)` : '';
                    
                    filterStatus.innerHTML = `
                        <div class="topic-filter-applied">
                            <span class="filter-info">Filtering by: ${topicName}${usageText}</span>
                            <span class="clear-filter" onclick="clearTopicFilter()">Clear Filter</span>
                        </div>
                    `;
                    filterStatus.style.display = 'block';
                } else {
                    document.getElementById('topic-filter-status').style.display = 'none';
                }
                
                console.log(`Filtered data: ${clusterData.length} clusters, ${userData.length} users`);
                
                // Re-render visualization
                renderVisualization();
                
            } catch (error) {
                console.error('Error fetching filtered data:', error);
                showStatus(`Error applying filter: ${error.message}`, true);
            } finally {
                setLoading(false);
            }
        }
        
        // Clear topic filter
        function clearTopicFilter() {
            document.getElementById('topic-filter').value = '';
            document.getElementById('min-usage').value = '1';
            currentTopicFilter = '';
            document.getElementById('topic-filter-status').style.display = 'none';
            
            // Fetch unfiltered data
            fetchData();
        }
        
        // Populate topic select dropdowns
        function populateTopicSelects() {
            const topicFilter = document.getElementById('topic-filter');
            const analysisTopicSelect = document.getElementById('analysis-topic-select');
            
            // Clear existing options (except the first "All Topics" / "Select Topic" option)
            topicFilter.innerHTML = '<option value="">All Topics</option>';
            analysisTopicSelect.innerHTML = '<option value="">-- Select Topic --</option>';
            
            // Add topics to both dropdowns
            topicsData.forEach(topic => {
                const option1 = document.createElement('option');
                option1.value = topic.name;
                option1.textContent = `${topic.name} (${topic.usage_count} uses)`;
                topicFilter.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = topic.name;
                option2.textContent = `${topic.name} (${topic.usage_count} uses)`;
                analysisTopicSelect.appendChild(option2);
            });
        }
        
        // Fetch feedback data for all users for visualization purposes
        async function fetchUserFeedbackForVisualization() {
            showStatus('Fetching user feedback data for visualization...');
            
            try {
                // Process each user sequentially to avoid overwhelming the server
                for (const user of userData) {
                    // Skip API calls for sample users (they have IDs like "user-0-1")
                    if (user.id.startsWith('user-')) {
                        // Generate mock feedback data for sample users
                        user.avg_feedback_rating = 3 + Math.random() * 2; // 3-5 rating
                        user.feedback_count = Math.floor(Math.random() * 20);
                        continue;
                    }
                    
                    try {
                        const response = await fetch(`http://localhost:3001/api/user-feedback/${user.id}`);
                        
                        if (!response.ok) {
                            console.warn(`Couldn't fetch feedback for user ${user.id}: ${response.statusText}`);
                            continue;
                        }
                        
                        const data = await response.json();
                        
                        if (data.feedback && data.feedback.length > 0) {
                            // Calculate average rating
                            const validRatings = data.feedback.filter(f => typeof f.rating === 'number' && f.rating > 0);
                            if (validRatings.length > 0) {
                                const totalRating = validRatings.reduce((sum, item) => sum + item.rating, 0);
                                user.avg_feedback_rating = Math.round((totalRating / validRatings.length) * 10) / 10;
                                user.feedback_count = validRatings.length;
                            }
                            
                            // Store feedback data for reference
                            userFeedbackData[user.id] = data.feedback;
                        }
                    } catch (error) {
                        console.warn(`Error fetching feedback for user ${user.id}:`, error);
                    }
                }
                
                console.log("User feedback data fetched for visualization.");
                hideStatus();
            } catch (error) {
                console.error("Error fetching user feedback for visualization:", error);
                showStatus("Error loading feedback data. Proceeding with limited data.", true);
            }
        }
        
        // Helper function to show loading state
        function setLoading(loading) {
            isLoading = loading;
            const loadingSpinner = document.getElementById('loading-spinner');
            if (loadingSpinner) {
                loadingSpinner.style.display = loading ? 'inline-block' : 'none';
            }
        }
        
        // Helper function to show status messages
        function showStatus(message, isError = false) {
            let statusDiv = document.getElementById('status-message');
            if (!statusDiv) {
                statusDiv = document.createElement('div');
                statusDiv.id = 'status-message';
                statusDiv.className = 'status-message';
                document.querySelector('.chart-container').prepend(statusDiv);
            }
            
            statusDiv.textContent = message;
            statusDiv.className = 'status-message' + (isError ? ' error-message' : '');
            statusDiv.style.display = 'block';
        }
        
        // Helper function to hide status messages
        function hideStatus() {
            const statusDiv = document.getElementById('status-message');
            if (statusDiv) {
                statusDiv.style.display = 'none';
            }
        }
        
        // Format dimension value based on dimension type
        function formatDimensionValue(value, dimension) {
            if (dimension === 'avg_feedback_rating') {
                return `${value}/5`;
            } else if (dimension === 'feedback_count') {
                return `${value} ratings`;
            } else {
                return `${Math.round(value)}/100`;
            }
        }
        
        // Get the appropriate domain range for a given dimension
        function getDimensionDomain(dimension) {
            if (dimension === 'avg_feedback_rating') {
                return [0, 5]; // Rating scale from 0-5
            } else if (dimension === 'feedback_count') {
                // Find max feedback count from user data
                const maxCount = userData.reduce((max, user) => Math.max(max, user.feedback_count || 0), 0);
                return [0, Math.max(maxCount, 1)]; // Make sure we don't have a 0 max
            } else {
                return [0, 100]; // Default scale for most dimensions
            }
        }
        
        function renderVisualization() {
            const svg = d3.select("#chart");
            const width = +svg.attr("width");
            const height = +svg.attr("height");
            const margin = { top: 40, right: 40, bottom: 60, left: 60 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;
            
            // Clear previous visualization
            svg.selectAll("*").remove();
            
            // Get selected dimensions
            const xDimension = document.getElementById("x-axis").value;
            const yDimension = document.getElementById("y-axis").value;
            
            // Process the data to extract interest values and feedback metrics if needed
            const processedUserData = userData.map(user => {
                const processedUser = {...user};
                
                // Process interest-based dimensions
                if (xDimension.startsWith('interest_') || yDimension.startsWith('interest_')) {
                    const interestCategories = {
                        science: ['Science', 'Physics', 'Chemistry', 'Biology', 'Astronomy'],
                        technology: ['Technology', 'Programming', 'Computers', 'Robotics', 'AI'],
                        sports: ['Sports', 'Basketball', 'Football', 'Soccer', 'Tennis', 'Swimming', 'Fitness'],
                        art: ['Art', 'Painting', 'Drawing', 'Photography', 'Design'],
                        music: ['Music', 'Guitar', 'Piano', 'Singing', 'Drums', 'Violin']
                    };
                    
                    // Calculate interest scores for each category
                    for (const [category, keywords] of Object.entries(interestCategories)) {
                        const matchCount = (user.interests || []).filter(interest => 
                            keywords.some(keyword => 
                                interest.toLowerCase().includes(keyword.toLowerCase())
                            )
                        ).length;
                        
                        // Calculate a score out of 100
                        processedUser[`interest_${category}`] = matchCount > 0 
                            ? Math.min(100, (matchCount / keywords.length) * 100) 
                            : 0;
                    }
                }
                
                // Process professional level (derived from education_level and occupation)
                if (xDimension === 'professional_level' || yDimension === 'professional_level') {
                    // Define a professional level score based on education and occupation
                    const eduLevelScores = {
                        'high_school': 20,
                        'associate': 40,
                        'undergraduate': 60,
                        'graduate': 80,
                        'postgraduate': 100
                    };
                    
                    const occupationScores = {
                        'student': 30,
                        'entry_level': 50,
                        'professional': 70,
                        'manager': 85,
                        'executive': 100
                    };
                    
                    // Calculate combined score
                    let eduScore = eduLevelScores[user.education_level] || 50;
                    let occScore = occupationScores[user.occupation] || 50;
                    
                    processedUser.professional_level = Math.round((eduScore + occScore) / 2);
                }
                
                return processedUser;
            });
            
            // Create scales with appropriate domains for the selected dimensions
            const xDomain = getDimensionDomain(xDimension);
            const yDomain = getDimensionDomain(yDimension);
            
            const xScale = d3.scaleLinear()
                .domain(xDomain)
                .range([0, innerWidth]);
                
            const yScale = d3.scaleLinear()
                .domain(yDomain)
                .range([innerHeight, 0]);
            
            // Create a color scale for clusters - use a nicer color palette - now globally accessible
            colorScale = d3.scaleOrdinal(d3.schemeTableau10)
                .domain(clusterData.map(d => d.id));
            
            const sizeScale = d3.scaleLinear()
                .domain([0, d3.max(clusterData, d => d.member_count) || 1])
                .range([5, 20]);
            
            // Create a group element for the chart
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);
            
            // Add grid lines for better readability
            g.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(0, ${innerHeight})`)
                .call(d3.axisBottom(xScale)
                    .tickSize(-innerHeight)
                    .tickFormat("")
                )
                .attr("stroke-opacity", 0.1)
                .select(".domain")
                .remove();
                
            g.append("g")
                .attr("class", "grid")
                .call(d3.axisLeft(yScale)
                    .tickSize(-innerWidth)
                    .tickFormat("")
                )
                .attr("stroke-opacity", 0.1)
                .select(".domain")
                .remove();
            
            // Create axes
            const xAxis = d3.axisBottom(xScale);
            const yAxis = d3.axisLeft(yScale);
            
            g.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0, ${innerHeight})`)
                .call(xAxis);
                
            g.append("g")
                .attr("class", "y-axis")
                .call(yAxis);
            
            // Add axis labels
            g.append("text")
                .attr("class", "x-axis-label")
                .attr("x", innerWidth / 2)
                .attr("y", innerHeight + 40)
                .style("text-anchor", "middle")
                .style("font-weight", "bold")
                .text(formatDimensionLabel(xDimension));
                
            g.append("text")
                .attr("class", "y-axis-label")
                .attr("transform", "rotate(-90)")
                .attr("x", -innerHeight / 2)
                .attr("y", -40)
                .style("text-anchor", "middle")
                .style("font-weight", "bold")
                .text(formatDimensionLabel(yDimension));
            
            // Create tooltip
            const tooltip = d3.select("body").selectAll(".tooltip").data([0])
                .join("div")
                .attr("class", "tooltip")
                .style("opacity", 0);
            
            // Define the simulation for force layout
            const simulation = d3.forceSimulation(processedUserData)
                .force("x", d3.forceX(d => xScale(d[xDimension])).strength(0.5))
                .force("y", d3.forceY(d => yScale(d[yDimension])).strength(0.5))
                .force("collide", d3.forceCollide(5).iterations(2))
                .stop();
            
            // Run the simulation
            for (let i = 0; i < 100; ++i) simulation.tick();
            
            // Plot cluster centroids with transition
            const centroids = g.selectAll(".cluster-centroid")
                .data(clusterData)
                .enter()
                .append("circle")
                .attr("class", "cluster-centroid")
                .attr("cx", d => {
                    // For cluster centroids, use the dimension value directly (scaled to 100)
                    let value = d.centroid[xDimension];
                    // If it's a custom dimension not in the centroid, use a default value
                    if (value === undefined) {
                        if (xDimension.startsWith('interest_')) {
                            // Use the average of users in this cluster for this interest
                            const clusterUsers = processedUserData.filter(u => u.cluster_id === d.id);
                            value = clusterUsers.length > 0 
                                ? d3.mean(clusterUsers, u => u[xDimension] || 0) / 100
                                : 0.5;
                        } else if (xDimension === 'professional_level') {
                            // Use a default value
                            value = 0.5;
                        } else if (xDimension === 'avg_feedback_rating') {
                            // Calculate the average feedback rating for this cluster
                            const clusterUsers = processedUserData.filter(u => u.cluster_id === d.id);
                            const usersWithFeedback = clusterUsers.filter(u => u.feedback_count > 0);
                            if (usersWithFeedback.length > 0) {
                                // Scale from 0-5 to 0-1 for compatibility with the 0-1 scale
                                value = d3.mean(usersWithFeedback, u => u.avg_feedback_rating) / 5;
                            } else {
                                value = 0;
                            }
                        } else if (xDimension === 'feedback_count') {
                            // Calculate the average feedback count for this cluster
                            const clusterUsers = processedUserData.filter(u => u.cluster_id === d.id);
                            if (clusterUsers.length > 0) {
                                const maxCount = d3.max(userData, u => u.feedback_count || 0);
                                value = d3.mean(clusterUsers, u => u.feedback_count || 0) / maxCount;
                            } else {
                                value = 0;
                            }
                        } else {
                            value = 0.5; // Default value
                        }
                    }
                    
                    // Use the appropriate scale
                    if (xDimension === 'avg_feedback_rating') {
                        return xScale(value * 5); // Scale from 0-1 to 0-5
                    } else if (xDimension === 'feedback_count') {
                        const maxCount = d3.max(userData, u => u.feedback_count || 0);
                        return xScale(value * maxCount);
                    } else {
                        return xScale(value * 100);
                    }
                })
                .attr("cy", d => {
                    // Similar handling for y-axis
                    let value = d.centroid[yDimension];
                    if (value === undefined) {
                        if (yDimension.startsWith('interest_')) {
                            const clusterUsers = processedUserData.filter(u => u.cluster_id === d.id);
                            value = clusterUsers.length > 0 
                                ? d3.mean(clusterUsers, u => u[yDimension] || 0) / 100
                                : 0.5;
                        } else if (yDimension === 'professional_level') {
                            value = 0.5;
                        } else if (yDimension === 'avg_feedback_rating') {
                            // Calculate the average feedback rating for this cluster
                            const clusterUsers = processedUserData.filter(u => u.cluster_id === d.id);
                            const usersWithFeedback = clusterUsers.filter(u => u.feedback_count > 0);
                            if (usersWithFeedback.length > 0) {
                                // Scale from 0-5 to 0-1 for compatibility with the 0-1 scale
                                value = d3.mean(usersWithFeedback, u => u.avg_feedback_rating) / 5;
                            } else {
                                value = 0;
                            }
                        } else if (yDimension === 'feedback_count') {
                            // Calculate the average feedback count for this cluster
                            const clusterUsers = processedUserData.filter(u => u.cluster_id === d.id);
                            if (clusterUsers.length > 0) {
                                const maxCount = d3.max(userData, u => u.feedback_count || 0);
                                value = d3.mean(clusterUsers, u => u.feedback_count || 0) / maxCount;
                            } else {
                                value = 0;
                            }
                        } else {
                            value = 0.5;
                        }
                    }
                    
                    // Use the appropriate scale
                    if (yDimension === 'avg_feedback_rating') {
                        return yScale(value * 5); // Scale from 0-1 to 0-5
                    } else if (yDimension === 'feedback_count') {
                        const maxCount = d3.max(userData, u => u.feedback_count || 0);
                        return yScale(value * maxCount);
                    } else {
                        return yScale(value * 100);
                    }
                })
                .attr("r", 0) // Start with radius 0 for animation
                .attr("fill", d => colorScale(d.id))
                .attr("stroke", "#333")
                .attr("stroke-width", 1.5)
                .attr("opacity", 0.8)
                .on("mouseover", function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr("stroke-width", 2.5)
                        .attr("opacity", 1);
                        
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", 1);
                        
                    // Get custom name or default    
                    const clusterName = d.metadata?.custom_name || `Cluster ${d.id.substring(0, 8)}...`;
                    
                    // Calculate cluster-wide feedback metrics
                    let feedbackInfo = '';
                    const clusterUsers = processedUserData.filter(u => u.cluster_id === d.id);
                    const usersWithFeedback = clusterUsers.filter(u => u.feedback_count > 0);
                    
                    if (usersWithFeedback.length > 0) {
                        const avgRating = d3.mean(usersWithFeedback, u => u.avg_feedback_rating);
                        const totalFeedbackCount = d3.sum(usersWithFeedback, u => u.feedback_count);
                        feedbackInfo = `
                            <p><strong>Avg. Feedback Rating:</strong> ${avgRating.toFixed(1)}/5</p>
                            <p><strong>Total Feedback:</strong> ${totalFeedbackCount} ratings</p>
                            <p><strong>Users With Feedback:</strong> ${usersWithFeedback.length}/${clusterUsers.length}</p>
                        `;
                    }
                    
                    tooltip.html(`
                        <h4>${clusterName}</h4>
                        <p><strong>Members:</strong> ${d.member_count}</p>
                        <p><strong>Technical Depth:</strong> ${Math.round(d.centroid.technical_depth * 100)}/100</p>
                        <p><strong>Visual Learning:</strong> ${Math.round(d.centroid.visual_learning * 100)}/100</p>
                        <p><strong>Practical Examples:</strong> ${Math.round(d.centroid.practical_examples * 100)}/100</p>
                        ${feedbackInfo}
                        <p><strong>Creation Method:</strong> ${d.metadata?.creation_method || 'Unknown'}</p>
                    `)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr("stroke-width", 1.5)
                        .attr("opacity", 0.8);
                        
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });
            
            // Animate centroids
            centroids.transition()
                .duration(800)
                .delay((d, i) => i * 100)
                .attr("r", d => sizeScale(d.member_count));
            
            // Add labels to centroids
            g.selectAll(".cluster-label")
                .data(clusterData)
                .enter()
                .append("text")
                .attr("class", "cluster-label")
                .attr("x", d => {
                    let value = d.centroid[xDimension];
                    if (value === undefined) {
                        if (xDimension.startsWith('interest_')) {
                            const clusterUsers = processedUserData.filter(u => u.cluster_id === d.id);
                            value = clusterUsers.length > 0 
                                ? d3.mean(clusterUsers, u => u[xDimension] || 0) / 100
                                : 0.5;
                        } else if (xDimension === 'professional_level') {
                            value = 0.5;
                        } else if (xDimension === 'avg_feedback_rating') {
                            // Calculate the average feedback rating for this cluster
                            const clusterUsers = processedUserData.filter(u => u.cluster_id === d.id);
                            const usersWithFeedback = clusterUsers.filter(u => u.feedback_count > 0);
                            if (usersWithFeedback.length > 0) {
                                // Scale from 0-5 to 0-1 for compatibility with the 0-1 scale
                                value = d3.mean(usersWithFeedback, u => u.avg_feedback_rating) / 5;
                            } else {
                                value = 0;
                            }
                        } else if (xDimension === 'feedback_count') {
                            // Calculate the average feedback count for this cluster
                            const clusterUsers = processedUserData.filter(u => u.cluster_id === d.id);
                            if (clusterUsers.length > 0) {
                                const maxCount = d3.max(userData, u => u.feedback_count || 0);
                                value = d3.mean(clusterUsers, u => u.feedback_count || 0) / maxCount;
                            } else {
                                value = 0;
                            }
                        } else {
                            value = 0.5;
                        }
                    }
                    return xScale(value * 100);
                })
                .attr("y", d => {
                    let value = d.centroid[yDimension];
                    if (value === undefined) {
                        if (yDimension.startsWith('interest_')) {
                            const clusterUsers = processedUserData.filter(u => u.cluster_id === d.id);
                            value = clusterUsers.length > 0 
                                ? d3.mean(clusterUsers, u => u[yDimension] || 0) / 100
                                : 0.5;
                        } else if (yDimension === 'professional_level') {
                            value = 0.5;
                        } else if (yDimension === 'avg_feedback_rating') {
                            // Calculate the average feedback rating for this cluster
                            const clusterUsers = processedUserData.filter(u => u.cluster_id === d.id);
                            const usersWithFeedback = clusterUsers.filter(u => u.feedback_count > 0);
                            if (usersWithFeedback.length > 0) {
                                // Scale from 0-5 to 0-1 for compatibility with the 0-1 scale
                                value = d3.mean(usersWithFeedback, u => u.avg_feedback_rating) / 5;
                            } else {
                                value = 0;
                            }
                        } else if (yDimension === 'feedback_count') {
                            // Calculate the average feedback count for this cluster
                            const clusterUsers = processedUserData.filter(u => u.cluster_id === d.id);
                            if (clusterUsers.length > 0) {
                                const maxCount = d3.max(userData, u => u.feedback_count || 0);
                                value = d3.mean(clusterUsers, u => u.feedback_count || 0) / maxCount;
                            } else {
                                value = 0;
                            }
                        } else {
                            value = 0.5;
                        }
                    }
                    return yScale(value * 100) - sizeScale(d.member_count) - 5;
                })
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("opacity", 0)
                .text(d => `C-${d.id.substring(0, 6)}`)
                .transition()
                .duration(800)
                .delay((d, i) => i * 100 + 500)
                .attr("opacity", 0.7);
            
            // Plot individual users with transition
            g.selectAll(".user-point")
                .data(processedUserData)
                .enter()
                .append("circle")
                .attr("class", "user-point")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", 0) // Start with radius 0 for animation
                .attr("fill", d => colorScale(d.cluster_id))
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .attr("opacity", 0.7)
                .on("mouseover", function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr("r", 6)
                        .attr("stroke-width", 2)
                        .attr("opacity", 1);
                        
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", 1);
                    
                    // Create a more detailed tooltip for users
                    let tooltipContent = `
                        <h4>${d.username || 'User'}</h4>
                        <p><strong>Learning Style:</strong> ${d.learning_style || 'Not specified'}</p>
                        <p><strong>Technical Depth:</strong> ${d.technical_depth}/100</p>
                        <p><strong>Visual Learning:</strong> ${Math.round(d.visual_learning)}/100</p>`;
                    
                    // Add feedback information if available
                    if (d.feedback_count > 0) {
                        tooltipContent += `
                        <p><strong>Avg. Feedback Rating:</strong> ${d.avg_feedback_rating}/5 (${d.feedback_count} ratings)</p>`;
                    }
                    
                    tooltipContent += `<p><strong>Cluster:</strong> ${d.cluster_id.substring(0, 8)}...</p>`;
                    
                    // Add axis-specific values if they're custom
                    if (xDimension.startsWith('interest_') || xDimension === 'professional_level' || 
                        xDimension === 'avg_feedback_rating' || xDimension === 'feedback_count') {
                        tooltipContent += `<p><strong>${formatDimensionLabel(xDimension)}:</strong> ${formatDimensionValue(d[xDimension], xDimension)}</p>`;
                    }
                    
                    if (yDimension.startsWith('interest_') || yDimension === 'professional_level' || 
                        yDimension === 'avg_feedback_rating' || yDimension === 'feedback_count') {
                        tooltipContent += `<p><strong>${formatDimensionLabel(yDimension)}:</strong> ${formatDimensionValue(d[yDimension], yDimension)}</p>`;
                    }
                    
                    // Add education and age if available
                    if (d.education_level) {
                        tooltipContent += `<p><strong>Education:</strong> ${d.education_level}</p>`;
                    }
                    if (d.age) {
                        tooltipContent += `<p><strong>Age:</strong> ${d.age}</p>`;
                    }
                    
                    // Add interests if available
                    if (d.interests && d.interests.length > 0) {
                        tooltipContent += `<p><strong>Interests:</strong> ${d.interests.join(', ')}</p>`;
                    }
                    
                    tooltip.html(tooltipContent)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr("r", 4)
                        .attr("stroke-width", 1.5)
                        .attr("opacity", 0.7);
                        
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                })
                .on("click", function(event, d) {
                    // Set the user selection dropdown to this user
                    const userSelect = document.getElementById('user-select');
                    userSelect.value = d.id;
                    
                    // Trigger the change event
                    const changeEvent = new Event('change');
                    userSelect.dispatchEvent(changeEvent);
                    
                    // Switch to the user preferences tab
                    document.querySelector('.tab[data-tab="userPreferences"]').click();
                })
                .transition()
                .duration(800)
                .delay((d, i) => i * 20)
                .attr("r", 4);
            
            // Create legend with enhanced styling and custom names
            createLegend();
            
            // Display cluster information
            displayClusterInfo(clusterData);
        }
        
        function displayClusterInfo(clusters) {
            const clusterInfoDiv = document.getElementById("cluster-info");
            clusterInfoDiv.innerHTML = "";
            
            const heading = document.createElement("h3");
            heading.textContent = "Cluster Details";
            clusterInfoDiv.appendChild(heading);
            
            clusters.forEach(cluster => {
                const clusterDiv = document.createElement("div");
                clusterDiv.style.marginBottom = "20px";
                clusterDiv.style.padding = "15px";
                clusterDiv.style.borderRadius = "8px";
                clusterDiv.style.backgroundColor = "#f9f9f9";
                clusterDiv.style.borderLeft = "4px solid " + d3.schemeTableau10[clusters.indexOf(cluster) % 10];
                
                // Use custom name if available
                const clusterName = cluster.metadata?.custom_name || `Cluster ${cluster.id.substring(0, 8)}...`;
                
                const clusterTitle = document.createElement("h4");
                clusterTitle.textContent = clusterName;
                clusterTitle.style.margin = "0 0 10px 0";
                clusterDiv.appendChild(clusterTitle);
                
                const clusterDetails = document.createElement("div");
                clusterDetails.innerHTML = `
                    <p><strong>Member Count:</strong> ${cluster.member_count}</p>
                    <p><strong>Creation Method:</strong> ${cluster.metadata?.creation_method || 'Unknown'}</p>
                    <p><strong>Technical Depth:</strong> ${Math.round(cluster.centroid.technical_depth * 100)}/100</p>
                    <p><strong>Visual Learning:</strong> ${Math.round(cluster.centroid.visual_learning * 100)}/100</p>
                    <p><strong>Practical Examples:</strong> ${Math.round(cluster.centroid.practical_examples * 100)}/100</p>
                `;
                
                // Add description if available
                if (cluster.metadata && cluster.metadata.description) {
                    const description = document.createElement("p");
                    description.innerHTML = `<strong>Description:</strong> ${cluster.metadata.description}`;
                    clusterDetails.appendChild(description);
                }
                
                clusterDiv.appendChild(clusterDetails);
                clusterInfoDiv.appendChild(clusterDiv);
            });
            
            // Add a message if no clusters
            if (clusters.length === 0) {
                const noDataMsg = document.createElement("p");
                noDataMsg.textContent = "No cluster data available. Please ensure your database has user clusters defined.";
                noDataMsg.style.padding = "15px";
                noDataMsg.style.backgroundColor = "#fff2f0";
                noDataMsg.style.borderRadius = "6px";
                clusterInfoDiv.appendChild(noDataMsg);
            }
        }
        
        function formatDimensionLabel(dimension) {
            return dimension
                .split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }
        
        function populateUserSelect() {
            const userSelect = document.getElementById('user-select');
            userSelect.innerHTML = '<option value="">-- Select User --</option>';
            
            userData.forEach(user => {
                const option = document.createElement('option');
                option.value = user.id;
                option.textContent = user.username || `User ${user.id.substring(0, 8)}...`;
                userSelect.appendChild(option);
            });
            
            // Populate checkbox groups
            populateCheckboxGroup('interests-group', INTERESTS);
            populateCheckboxGroup('analogy-domains-group', ANALOGY_DOMAINS);
            
            // Add event listener to user select
            userSelect.addEventListener('change', function() {
                const userId = this.value;
                if (userId) {
                    const user = userData.find(u => u.id === userId);
                    displayUserDetails(user);
                } else {
                    document.getElementById('user-details').style.display = 'none';
                }
            });
            
            // Add event listener to preference form
            document.getElementById('preference-form').addEventListener('submit', function(e) {
                e.preventDefault();
                updateUserPreferences();
            });
            
            // Add event listener to technical depth slider
            document.getElementById('technical-depth').addEventListener('input', function() {
                document.getElementById('technical-depth-value').textContent = this.value;
            });
        }
        
        function populateCheckboxGroup(elementId, options) {
            const container = document.getElementById(elementId);
            container.innerHTML = '';
            
            options.forEach(option => {
                const div = document.createElement('div');
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `${elementId}-${option.toLowerCase().replace(/\s/g, '-')}`;
                checkbox.name = elementId === 'interests-group' ? 'interests' : 'analogy_domains';
                checkbox.value = option;
                
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = option;
                
                div.appendChild(checkbox);
                div.appendChild(label);
                container.appendChild(div);
            });
        }
        
        function displayUserDetails(user) {
            const userDetails = document.getElementById('user-details');
            const currentInfo = document.getElementById('current-info');
            
            // Display user info
            currentInfo.innerHTML = `
                <p><strong>Username:</strong> ${user.username || 'Not specified'}</p>
                <p><strong>Learning Style:</strong> ${user.learning_style || 'Not specified'}</p>
                <p><strong>Technical Depth:</strong> ${user.technical_depth}/100</p>
                <p><strong>Age:</strong> ${user.age || 'Not specified'}</p>
                <p><strong>Education Level:</strong> ${user.education_level || 'Not specified'}</p>
                <p><strong>Occupation:</strong> ${user.occupation || 'Not specified'}</p>
                <p><strong>Learning Goal:</strong> ${user.main_learning_goal || 'Not specified'}</p>
                <p><strong>Interests:</strong> ${user.interests?.join(', ') || 'None'}</p>
                <p><strong>Analogy Domains:</strong> ${user.preferred_analogy_domains?.join(', ') || 'None'}</p>
                <p><strong>Current Cluster:</strong> ${user.cluster_id?.substring(0, 8) || 'Unassigned'}...</p>
            `;
            
            // Fetch and display user conversation feedback
            fetchUserFeedback(user.id);
            
            // Set form values
            document.getElementById('technical-depth').value = user.technical_depth || 50;
            document.getElementById('technical-depth-value').textContent = user.technical_depth || 50;
            
            const learningStyleSelect = document.getElementById('learning-style');
            for (let i = 0; i < learningStyleSelect.options.length; i++) {
                if (learningStyleSelect.options[i].value === user.learning_style) {
                    learningStyleSelect.selectedIndex = i;
                    break;
                }
            }
            
            // Clear all checkboxes
            document.querySelectorAll('#interests-group input, #analogy-domains-group input').forEach(cb => {
                cb.checked = false;
            });
            
            // Set interests checkboxes
            if (user.interests) {
                user.interests.forEach(interest => {
                    const checkbox = document.querySelector(`#interests-group-${interest.toLowerCase().replace(/\s/g, '-')}`);
                    if (checkbox) checkbox.checked = true;
                });
            }
            
            // Set analogy domains checkboxes
            if (user.preferred_analogy_domains) {
                user.preferred_analogy_domains.forEach(domain => {
                    const checkbox = document.querySelector(`#analogy-domains-group-${domain.toLowerCase().replace(/\s/g, '-')}`);
                    if (checkbox) checkbox.checked = true;
                });
            }
            
            userDetails.style.display = 'block';
        }
        
        // Function to fetch user conversation feedback
        async function fetchUserFeedback(userId) {
            const feedbackHistory = document.getElementById('feedback-history');
            feedbackHistory.innerHTML = '<p id="feedback-loading">Loading conversation feedback...</p>';
            
            try {
                const response = await fetch(`http://localhost:3001/api/user-feedback/${userId}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch user feedback: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Check for message indicating system not configured
                if (data.message) {
                    feedbackHistory.innerHTML = `<p>${data.message}</p>`;
                    return;
                }
                
                if (!data.feedback || data.feedback.length === 0) {
                    feedbackHistory.innerHTML = '<p>No conversation feedback found for this user.</p>';
                    return;
                }
                
                // Display feedback
                feedbackHistory.innerHTML = '';
                
                // Add debug information 
                const debugInfo = document.createElement('div');
                debugInfo.style.backgroundColor = '#f0f2f5';
                debugInfo.style.padding = '10px';
                debugInfo.style.marginBottom = '15px';
                debugInfo.style.borderRadius = '4px';
                debugInfo.innerHTML = `<strong>Debug:</strong> Found ${data.feedback.length} feedback items<br>`;
                
                if (data.feedback.length > 0) {
                    const firstItem = data.feedback[0];
                    debugInfo.innerHTML += `First item rating (raw): <code>${JSON.stringify(firstItem.rating)}</code><br>`;
                    debugInfo.innerHTML += `First item rating (parsed): <code>${typeof firstItem.rating === 'number' ? firstItem.rating : Number(firstItem.rating) || 0}</code>`;
                }
                
                // Uncomment this line to show debug info
                // feedbackHistory.appendChild(debugInfo);
                
                data.feedback.forEach(item => {
                    // Ensure rating is properly parsed as a number
                    const rating = typeof item.rating === 'number' ? item.rating : Number(item.rating) || 0;
                    console.log('Item rating:', item.rating, 'Parsed to:', rating);
                    
                    const feedbackItem = document.createElement('div');
                    feedbackItem.className = 'feedback-item';
                    
                    // Determine feedback class based on rating
                    let feedbackClass = 'feedback-neutral';
                    if (rating >= 4) {
                        feedbackClass = 'feedback-positive';
                    } else if (rating <= 2) {
                        feedbackClass = 'feedback-negative';
                    }
                    
                    // Format date
                    const feedbackDate = new Date(item.timestamp);
                    const formattedDate = feedbackDate.toLocaleString();
                    
                    // Process the system response to extract relevant content
                    let formattedSystemResponse = item.system_response;
                    
                    try {
                        // Check if it's a JSON string
                        if (typeof item.system_response === 'string' && 
                            (item.system_response.startsWith('{') || item.system_response.startsWith('['))) {
                            
                            const responseObj = JSON.parse(item.system_response);
                            
                            // Extract the most relevant parts for display
                            if (responseObj.explanation) {
                                formattedSystemResponse = responseObj.explanation;
                            } else if (responseObj.recap) {
                                formattedSystemResponse = responseObj.recap;
                            } else if (responseObj.response) {
                                formattedSystemResponse = responseObj.response;
                            } else if (responseObj.text) {
                                formattedSystemResponse = responseObj.text;
                            } else if (responseObj.content) {
                                formattedSystemResponse = responseObj.content;
                            }
                        }
                    } catch (e) {
                        console.log('Error parsing system response as JSON, using raw text');
                        // Keep original text if JSON parsing fails
                    }
                    
                    // Truncate long text for better display
                    const truncateText = (text, maxLength = 250) => {
                        if (!text) return 'No text recorded';
                        if (text.length <= maxLength) return text;
                        return text.substring(0, maxLength) + '...';
                    };
                    
                    // Create star rating display
                    const createStarRating = (rating) => {
                        const fullStars = Math.floor(rating);
                        const halfStar = rating % 1 >= 0.5;
                        const emptyStars = 5 - fullStars - (halfStar ? 1 : 0);
                        
                        let starsHtml = '';
                        
                        // Add full stars
                        for (let i = 0; i < fullStars; i++) {
                            starsHtml += '<span class="star full-star">★</span>';
                        }
                        
                        // Add half star if needed
                        if (halfStar) {
                            starsHtml += '<span class="star half-star">★</span>';
                        }
                        
                        // Add empty stars
                        for (let i = 0; i < emptyStars; i++) {
                            starsHtml += '<span class="star empty-star">☆</span>';
                        }
                        
                        return `<div class="star-rating ${feedbackClass}">${starsHtml}</div>`;
                    };
                    
                    feedbackItem.innerHTML = `
                        <div class="user-input">
                            <strong>User:</strong> ${truncateText(item.user_input)}
                        </div>
                        <div class="system-response">
                            <strong>System:</strong> ${truncateText(formattedSystemResponse)}
                        </div>
                        <div class="user-feedback">
                            <div class="feedback-rating-container">
                                ${createStarRating(rating)}
                                <span class="rating-text ${feedbackClass}">${rating}/5</span>
                            </div>
                            <span class="feedback-comment">${item.comment || ''}</span>
                            <span class="feedback-date">${formattedDate}</span>
                        </div>
                    `;
                    
                    // Add expand/collapse functionality for long conversations
                    if ((item.user_input && item.user_input.length > 250) || 
                        (formattedSystemResponse && formattedSystemResponse.length > 250)) {
                        const expandButton = document.createElement('button');
                        expandButton.textContent = 'Show full conversation';
                        expandButton.className = 'expand-btn';
                        expandButton.style.cssText = 'margin-top: 10px; font-size: 12px; padding: 5px 10px;';
                        
                        expandButton.addEventListener('click', function() {
                            if (this.textContent === 'Show full conversation') {
                                feedbackItem.querySelector('.user-input').innerHTML = 
                                    `<strong>User:</strong> ${item.user_input || 'No input recorded'}`;
                                feedbackItem.querySelector('.system-response').innerHTML = 
                                    `<strong>System:</strong> ${formattedSystemResponse || 'No response recorded'}`;
                                this.textContent = 'Show less';
                            } else {
                                feedbackItem.querySelector('.user-input').innerHTML = 
                                    `<strong>User:</strong> ${truncateText(item.user_input)}`;
                                feedbackItem.querySelector('.system-response').innerHTML = 
                                    `<strong>System:</strong> ${truncateText(formattedSystemResponse)}`;
                                this.textContent = 'Show full conversation';
                            }
                        });
                        
                        feedbackItem.appendChild(expandButton);
                    }
                    
                    feedbackHistory.appendChild(feedbackItem);
                });
                
                // Add CSS styles for stars
                const styleEl = document.createElement('style');
                styleEl.textContent = `
                    .star-rating {
                        display: inline-flex;
                        font-size: 18px;
                        margin-right: 8px;
                    }
                    .star {
                        margin-right: 2px;
                    }
                    .full-star, .half-star {
                        color: gold;
                        text-shadow: 0 0 1px #333;
                    }
                    .empty-star {
                        color: #ccc;
                    }
                    .feedback-rating-container {
                        display: flex;
                        align-items: center;
                    }
                    .rating-text {
                        font-weight: bold;
                        font-size: 14px;
                    }
                    .feedback-positive {
                        color: #42b983;
                    }
                    .feedback-negative {
                        color: #e75c3c;
                    }
                `;
                document.head.appendChild(styleEl);
                
            } catch (error) {
                console.error('Error fetching user feedback:', error);
                feedbackHistory.innerHTML = `<p>Error loading feedback: ${error.message}</p>`;
            }
        }
        
        async function updateUserPreferences() {
            const userId = document.getElementById('user-select').value;
            if (!userId) return;
            
            setLoading(true);
            showStatus('Updating user preferences...');
            
            const technicalDepth = parseInt(document.getElementById('technical-depth').value);
            const learningStyle = document.getElementById('learning-style').value;
            
            // Get selected interests
            const interests = Array.from(document.querySelectorAll('#interests-group input:checked')).map(cb => cb.value);
            
            // Get selected analogy domains
            const analogyDomains = Array.from(document.querySelectorAll('#analogy-domains-group input:checked')).map(cb => cb.value);
            
            try {
                const response = await fetch('http://localhost:3001/api/update-user-preferences', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_id: userId,
                        technical_depth: technicalDepth,
                        learning_style: learningStyle,
                        interests: interests,
                        preferred_analogy_domains: analogyDomains
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to update preferences: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                showStatus(`Preferences updated successfully! ${result.message || 'User may have been reassigned to a different cluster.'}`);
                
                // Refresh data after a short delay
                setTimeout(() => {
                    fetchData();
                }, 1500);
            } catch (error) {
                console.error('Error updating user preferences:', error);
                showStatus(`Error updating preferences: ${error.message}`, true);
            } finally {
                setLoading(false);
            }
        }
        
        // Move all initialization code into DOMContentLoaded event
        document.addEventListener('DOMContentLoaded', function() {
            // Apply dimensions button click handler
            document.getElementById('apply-dimensions').addEventListener('click', function() {
                // Check if we need to fetch filtered data or just re-render
                const topic = document.getElementById('topic-filter').value;
                const minUsage = document.getElementById('min-usage').value;
                
                if (topic || (minUsage && parseInt(minUsage) > 1)) {
                    fetchFilteredData();
                } else {
                    renderVisualization();
                }
            });
            
            // Reset filters button
            document.getElementById('reset-filters').addEventListener('click', clearTopicFilter);
            
            // Topic analysis event listeners
            document.getElementById('analyze-topic-btn')?.addEventListener('click', function() {
                const selectedTopic = document.getElementById('analysis-topic-select').value;
                if (selectedTopic) {
                    analyzeTopic(selectedTopic);
                } else {
                    alert('Please select a topic to analyze');
                }
            });
            
            document.getElementById('analyze-all-topics-btn')?.addEventListener('click', analyzeAllTopics);
            
            document.getElementById('show-topic-heatmap-btn')?.addEventListener('click', function() {
                // TODO: Implement heatmap visualization
                alert('Topic heatmap feature coming soon!');
            });
            
            // Create custom cluster button click handler
            document.getElementById('create-cluster')?.addEventListener('click', createCustomCluster);
            
            // New listeners
            document.getElementById('create-interest-cluster')?.addEventListener('click', createInterestCluster);
            document.getElementById('apply-naming-strategy')?.addEventListener('click', applyNamingStrategy);
            
            // Similar Topics functionality
            document.getElementById('fetch-topics-btn')?.addEventListener('click', function() {
                const userId = document.getElementById('similar-user-select').value;
                fetchSimilarUserTopics(userId);
            });
            
            // Tab switching functionality
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active class from all tabs and content
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding content
                    tab.classList.add('active');
                    const contentId = tab.dataset.tab;
                    const content = document.getElementById(contentId);
                    if (content) {
                        content.classList.add('active');
                        
                        // If switching to the similar topics tab, populate the user select
                        if (contentId === 'similarTopics') {
                            populateSimilarUserSelect();
                        }
                        
                        // If switching to topic analysis tab, populate topic select if empty
                        if (contentId === 'topicAnalysis') {
                            const analysisSelect = document.getElementById('analysis-topic-select');
                            if (analysisSelect.children.length <= 1) {
                                populateTopicSelects();
                            }
                        }
                    }
                });
            });
            
            // Sub tabs for cluster management
            document.querySelectorAll('.sub-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    // Remove active class from all tabs and content
                    document.querySelectorAll('.sub-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.subtab-content').forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding content
                    this.classList.add('active');
                    const subtabId = this.dataset.subtab;
                    const subtabContent = document.getElementById(subtabId);
                    if (subtabContent) {
                        subtabContent.classList.add('active');
                        
                        // Additional initialization based on tab
                        if (subtabId === 'rename-clusters') {
                            displayClusterNamingOptions();
                        }
                    }
                });
            });
            
            // Add event listeners to the axis selectors
            document.getElementById("x-axis")?.addEventListener("change", renderVisualization);
            document.getElementById("y-axis")?.addEventListener("change", renderVisualization);
            
            // Add a loading spinner to the chart container
            const chartContainer = document.querySelector('.chart-container');
            if (chartContainer) {
                const chartHeader = document.createElement('div');
                chartHeader.className = 'chart-header';
                chartHeader.innerHTML = `
                    <h3>User Cluster Visualization</h3>
                    <div>
                        <span id="loading-spinner" class="loading-spinner" style="display: none;"></span>
                    </div>
                `;
                chartContainer.prepend(chartHeader);
            }
            
            // Initial data load
            fetchData();
        });
        
        // Custom cluster creation
        let customClusters = [];
        
        // ... [rest of the code remains unchanged]
        
        // Create legend function
        function createLegend() {
            const legend = d3.select("#legend");
            legend.selectAll("*").remove();
            
            clusterData.forEach(cluster => {
                // Use custom name if available
                const clusterName = cluster.metadata?.custom_name || `Cluster ${cluster.id.substring(0, 6)}...`;
                
                const legendItem = legend.append("div")
                    .attr("class", "legend-item")
                    .on("mouseover", function() {
                        d3.select(this).style("background-color", "#e0e0e0");
                        
                        // Highlight this cluster's centroid and users
                        d3.selectAll(".cluster-centroid")
                            .filter(d => d.id === cluster.id)
                            .transition()
                            .duration(200)
                            .attr("opacity", 1)
                            .attr("stroke-width", 2.5);
                            
                        d3.selectAll(".user-point")
                            .filter(d => d.cluster_id === cluster.id)
                            .transition()
                            .duration(200)
                            .attr("opacity", 1)
                            .attr("stroke-width", 2);
                            
                        d3.selectAll(".user-point")
                            .filter(d => d.cluster_id !== cluster.id)
                            .transition()
                            .duration(200)
                            .attr("opacity", 0.3);
                    })
                    .on("mouseout", function() {
                        d3.select(this).style("background-color", "#f0f2f5");
                        
                        // Restore all elements
                        d3.selectAll(".cluster-centroid")
                            .transition()
                            .duration(200)
                            .attr("opacity", 0.8)
                            .attr("stroke-width", 1.5);
                            
                        d3.selectAll(".user-point")
                            .transition()
                            .duration(200)
                            .attr("opacity", 0.7)
                            .attr("stroke-width", 1.5);
                    });
                
                legendItem.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", colorScale(cluster.id));
                
                legendItem.append("div")
                    .html(`<strong>${clusterName}</strong> (${cluster.member_count} users)`);
            });
        }
        
        // Topic Analysis Functions
        async function analyzeTopic(topicName) {
            try {
                setLoading(true);
                showTopicAnalysisStatus('Analyzing topic: ' + topicName);
                
                try {
                    // Get topic-specific cluster data
                    const response = await fetch(`http://localhost:3001/api/clusters/by-topic?topic=${encodeURIComponent(topicName)}`);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch topic analysis: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    
                    // Show topic statistics
                    displayTopicStats(topicName, data);
                    
                    // Show cluster distribution for this topic
                    displayTopicClusterDistribution(topicName, data);
                    
                    // Generate insights
                    generateTopicInsights(topicName, data);
                } catch (apiError) {
                    console.warn('API endpoint failed, using mock data for topic analysis:', apiError);
                    
                    // Create mock data for demonstration
                    const mockData = {
                        clusters: clusterData.slice(0, 3).map(cluster => ({
                            ...cluster,
                            topic_stats: {
                                total_sessions: Math.floor(Math.random() * 10) + 1,
                                topic_counts: {
                                    [topicName]: Math.floor(Math.random() * 5) + 1
                                },
                                dominant_topic: topicName,
                                unique_topics: 1
                            }
                        })),
                        topic_stats: {
                            [topicName]: Math.floor(Math.random() * 15) + 5
                        }
                    };
                    
                    displayTopicStats(topicName, mockData);
                    displayTopicClusterDistribution(topicName, mockData);
                    generateTopicInsights(topicName, mockData);
                }
                
                hideTopicAnalysisStatus();
            } catch (error) {
                console.error('Error analyzing topic:', error);
                showTopicAnalysisStatus(`Error analyzing topic: ${error.message}`, true);
            } finally {
                setLoading(false);
            }
        }
        
        async function analyzeAllTopics() {
            try {
                setLoading(true);
                showTopicAnalysisStatus('Analyzing all topics...');
                
                try {
                    const response = await fetch('http://localhost:3001/api/clusters/topic-distribution');
                    if (!response.ok) {
                        throw new Error(`Failed to fetch topic distribution: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    
                    // Display overview statistics
                    displayAllTopicsOverview(data.distribution);
                } catch (apiError) {
                    console.warn('API endpoint failed, using mock data for all topics analysis:', apiError);
                    
                    // Create mock distribution data
                    const mockDistribution = {};
                    clusterData.forEach(cluster => {
                        mockDistribution[cluster.id] = {};
                        topicsData.slice(0, 3).forEach(topic => {
                            mockDistribution[cluster.id][topic.name] = Math.floor(Math.random() * 5) + 1;
                        });
                    });
                    
                    displayAllTopicsOverview(mockDistribution);
                }
                
                hideTopicAnalysisStatus();
            } catch (error) {
                console.error('Error analyzing all topics:', error);
                showTopicAnalysisStatus(`Error analyzing topics: ${error.message}`, true);
            } finally {
                setLoading(false);
            }
        }
        
        function displayTopicStats(topicName, data) {
            const statsContainer = document.getElementById('topic-stats-content');
            const statsOverview = document.getElementById('topic-stats-overview');
            
            let totalSessions = 0;
            let clustersWithTopic = 0;
            
            data.clusters.forEach(cluster => {
                if (cluster.topic_stats && cluster.topic_stats.topic_counts[topicName]) {
                    totalSessions += cluster.topic_stats.topic_counts[topicName];
                    clustersWithTopic++;
                }
            });
            
            const topicInfo = topicsData.find(t => t.name === topicName);
            const globalUsage = topicInfo ? topicInfo.usage_count : totalSessions;
            
            statsContainer.innerHTML = `
                <div class="topic-stat-card">
                    <h4>${topicName}</h4>
                    <div class="stat-value">${globalUsage}</div>
                    <div class="stat-label">Total Usage</div>
                </div>
                <div class="topic-stat-card">
                    <h4>Cluster Presence</h4>
                    <div class="stat-value">${clustersWithTopic}</div>
                    <div class="stat-label">Clusters Using Topic</div>
                </div>
                <div class="topic-stat-card">
                    <h4>Average per Cluster</h4>
                    <div class="stat-value">${clustersWithTopic > 0 ? Math.round(totalSessions / clustersWithTopic) : 0}</div>
                    <div class="stat-label">Sessions per Cluster</div>
                </div>
                <div class="topic-stat-card">
                    <h4>Popularity</h4>
                    <div class="stat-value">${Math.round((clustersWithTopic / data.clusters.length) * 100)}%</div>
                    <div class="stat-label">Cluster Coverage</div>
                </div>
            `;
            
            statsOverview.style.display = 'block';
        }
        
        function displayAllTopicsOverview(distribution) {
            const statsContainer = document.getElementById('topic-stats-content');
            const statsOverview = document.getElementById('topic-stats-overview');
            
            // Calculate statistics across all topics
            const allTopics = new Set();
            const clusterCounts = {};
            let totalSessions = 0;
            
            Object.values(distribution).forEach(clusterTopics => {
                Object.entries(clusterTopics).forEach(([topic, count]) => {
                    allTopics.add(topic);
                    totalSessions += count;
                    clusterCounts[topic] = (clusterCounts[topic] || 0) + 1;
                });
            });
            
            // Find most popular topics
            const topicPopularity = Array.from(allTopics).map(topic => ({
                name: topic,
                clusters: clusterCounts[topic] || 0,
                totalUsage: topicsData.find(t => t.name === topic)?.usage_count || 0
            })).sort((a, b) => b.totalUsage - a.totalUsage).slice(0, 5);
            
            let topicCards = '';
            topicPopularity.forEach(topic => {
                topicCards += `
                    <div class="topic-stat-card">
                        <h4>${topic.name}</h4>
                        <div class="stat-value">${topic.totalUsage}</div>
                        <div class="stat-label">Uses in ${topic.clusters} clusters</div>
                    </div>
                `;
            });
            
            statsContainer.innerHTML = `
                <div class="topic-stat-card">
                    <h4>Total Topics</h4>
                    <div class="stat-value">${allTopics.size}</div>
                    <div class="stat-label">Unique Topics</div>
                </div>
                <div class="topic-stat-card">
                    <h4>Total Sessions</h4>
                    <div class="stat-value">${totalSessions}</div>
                    <div class="stat-label">Classified Sessions</div>
                </div>
                <div class="topic-stat-card">
                    <h4>Active Clusters</h4>
                    <div class="stat-value">${Object.keys(distribution).length}</div>
                    <div class="stat-label">Clusters with Topics</div>
                </div>
                ${topicCards}
            `;
            
            statsOverview.style.display = 'block';
        }
        
        function displayTopicClusterDistribution(topicName, data) {
            const distributionContainer = document.getElementById('topic-cluster-distribution');
            const svg = d3.select("#topic-distribution-chart");
            
            svg.selectAll("*").remove();
            
            // Prepare data for visualization
            const chartData = data.clusters
                .filter(cluster => cluster.topic_stats && cluster.topic_stats.topic_counts[topicName])
                .map(cluster => ({
                    clusterId: cluster.id.substring(0, 8),
                    clusterName: cluster.metadata?.custom_name || `Cluster ${cluster.id.substring(0, 8)}`,
                    usage: cluster.topic_stats.topic_counts[topicName],
                    memberCount: cluster.member_count
                }))
                .sort((a, b) => b.usage - a.usage);
            
            if (chartData.length === 0) {
                distributionContainer.innerHTML = '<p>No clusters found using this topic.</p>';
                return;
            }
            
            // Set up chart dimensions
            const margin = { top: 20, right: 30, bottom: 40, left: 120 };
            const width = 800 - margin.left - margin.right;
            const height = Math.max(400, chartData.length * 40) - margin.top - margin.bottom;
            
            const chart = svg
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Scales
            const xScale = d3.scaleLinear()
                .domain([0, d3.max(chartData, d => d.usage)])
                .range([0, width]);
            
            const yScale = d3.scaleBand()
                .domain(chartData.map(d => d.clusterName))
                .range([0, height])
                .padding(0.1);
            
            // Bars
            chart.selectAll(".bar")
                .data(chartData)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", 0)
                .attr("y", d => yScale(d.clusterName))
                .attr("width", d => xScale(d.usage))
                .attr("height", yScale.bandwidth())
                .attr("fill", "#4a90e2");
            
            // Axes
            chart.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale));
            
            chart.append("g")
                .call(d3.axisLeft(yScale));
            
            // Labels
            chart.selectAll(".label")
                .data(chartData)
                .enter().append("text")
                .attr("class", "label")
                .attr("x", d => xScale(d.usage) + 5)
                .attr("y", d => yScale(d.clusterName) + yScale.bandwidth() / 2)
                .attr("dy", "0.35em")
                .text(d => `${d.usage} uses`);
            
            distributionContainer.style.display = 'block';
        }
        
        function generateTopicInsights(topicName, data) {
            const insightsContainer = document.getElementById('insights-content');
            const insightsDiv = document.getElementById('topic-insights');
            
            let insights = [];
            
            // Analyze cluster characteristics for this topic
            const clustersWithTopic = data.clusters.filter(cluster => 
                cluster.topic_stats && cluster.topic_stats.topic_counts[topicName]
            );
            
            if (clustersWithTopic.length === 0) {
                insights.push({
                    title: 'Limited Usage',
                    content: `The topic "${topicName}" is not being used by any clusters in the current dataset.`
                });
            } else {
                // Most active cluster
                const mostActive = clustersWithTopic.reduce((max, cluster) => 
                    cluster.topic_stats.topic_counts[topicName] > max.topic_stats.topic_counts[topicName] ? cluster : max
                );
                
                insights.push({
                    title: 'Most Active Cluster',
                    content: `${mostActive.metadata?.custom_name || 'Cluster ' + mostActive.id.substring(0, 8)} shows the highest engagement with "${topicName}" (${mostActive.topic_stats.topic_counts[topicName]} sessions).`
                });
                
                // Cluster diversity
                if (clustersWithTopic.length > 1) {
                    insights.push({
                        title: 'Topic Popularity',
                        content: `"${topicName}" is popular across ${clustersWithTopic.length} different clusters, indicating broad appeal across different learning styles.`
                    });
                }
                
                // Usage intensity
                const totalUsage = clustersWithTopic.reduce((sum, cluster) => 
                    sum + cluster.topic_stats.topic_counts[topicName], 0
                );
                const avgUsage = totalUsage / clustersWithTopic.length;
                
                if (avgUsage > 5) {
                    insights.push({
                        title: 'High Engagement',
                        content: `This topic shows high engagement with an average of ${Math.round(avgUsage)} sessions per cluster.`
                    });
                }
            }
            
            // Display insights
            insightsContainer.innerHTML = insights.map(insight => `
                <div class="insight-item">
                    <h4>${insight.title}</h4>
                    <p>${insight.content}</p>
                </div>
            `).join('');
            
            insightsDiv.style.display = 'block';
        }
        
        function showTopicAnalysisStatus(message, isError = false) {
            console.log(message);
        }
        
        function hideTopicAnalysisStatus() {
            // Implementation for hiding status
        }
        
        // Additional missing functions
        function populateSimilarUserSelect() {
            const userSelect = document.getElementById('similar-user-select');
            userSelect.innerHTML = '<option value="">-- Select User --</option>';
            
            userData.forEach(user => {
                const option = document.createElement('option');
                option.value = user.id;
                option.textContent = user.username || `User ${user.id.substring(0, 8)}...`;
                userSelect.appendChild(option);
            });
        }
        
        async function fetchSimilarUserTopics(userId) {
            if (!userId) {
                alert('Please select a user first');
                return;
            }
            
            try {
                setLoading(true);
                
                const container = document.getElementById('similar-topics-container');
                const topicsList = document.getElementById('similar-topics-list');
                const clusterPreferences = document.getElementById('cluster-preferences');
                
                container.style.display = 'block';
                topicsList.innerHTML = '<p id="topics-loading">Loading topics from your cluster...</p>';
                
                const response = await fetch(`http://localhost:3001/api/clusters/cluster-topics/${userId}`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch topics: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.message) {
                    topicsList.innerHTML = `<div class="no-topics-message">${data.message}</div>`;
                    return;
                }
                
                if (!data.topics || data.topics.length === 0) {
                    topicsList.innerHTML = `<div class="no-topics-message">No recent topics found from users in your cluster.</div>`;
                    return;
                }
                
                // Display cluster preferences if available
                const user = userData.find(u => u.id === userId);
                if (user && user.cluster_id) {
                    const cluster = clusterData.find(c => c.id === user.cluster_id);
                    if (cluster) {
                        clusterPreferences.innerHTML = `
                            <h4>Your Cluster Information</h4>
                            <p><strong>Cluster:</strong> ${cluster.metadata?.custom_name || `Cluster ${cluster.id.substring(0, 8)}...`}</p>
                            <p><strong>Members:</strong> ${cluster.member_count} users</p>
                            <p><strong>Technical Depth:</strong> ${Math.round(cluster.centroid.technical_depth * 100)}/100</p>
                            <p><strong>Visual Learning:</strong> ${Math.round(cluster.centroid.visual_learning * 100)}/100</p>
                        `;
                        clusterPreferences.style.display = 'block';
                    }
                }
                
                // Display topics
                topicsList.innerHTML = '';
                
                const topicsTitle = document.createElement('div');
                topicsTitle.className = 'topics-title';
                topicsTitle.innerHTML = `<h4>Recent Topics from Your Cluster (${data.topics.length} found)</h4>`;
                topicsList.appendChild(topicsTitle);
                
                data.topics.forEach(topic => {
                    const topicItem = document.createElement('div');
                    topicItem.className = 'topic-item';
                    
                    const topicDate = new Date(topic.timestamp);
                    const formattedDate = topicDate.toLocaleDateString() + ' ' + topicDate.toLocaleTimeString();
                    
                    topicItem.innerHTML = `
                        <div class="topic-header">
                            <span class="topic-user">${topic.username}</span>
                            <span class="topic-date">${formattedDate}</span>
                        </div>
                        <div class="topic-name">${topic.topic}</div>
                        <div class="topic-query">${topic.query}</div>
                    `;
                    
                    topicsList.appendChild(topicItem);
                });
                
            } catch (error) {
                console.error('Error fetching similar user topics:', error);
                const topicsList = document.getElementById('similar-topics-list');
                topicsList.innerHTML = `
                    <div class="no-topics-message error-message">
                        <strong>Error loading topics:</strong> ${error.message}
                        <p>This could happen if:</p>
                        <ul>
                            <li>The user is not assigned to a cluster yet</li>
                            <li>There are no other users in the same cluster</li>
                            <li>No recent conversation data is available</li>
                        </ul>
                    </div>
                `;
            } finally {
                setLoading(false);
            }
        }
        
        // Cluster management functions (stubs for now)
        function createCustomCluster() {
            alert('Custom cluster creation feature coming soon!');
        }
        
        function createInterestCluster() {
            alert('Interest-based cluster creation feature coming soon!');
        }
        
        function applyNamingStrategy() {
            alert('Cluster naming strategy feature coming soon!');
        }
        
        function displayClusterNamingOptions() {
            const namingList = document.getElementById('cluster-naming-list');
            if (namingList) {
                namingList.innerHTML = '<p>Loading cluster naming options...</p>';
                // Implementation for cluster naming would go here
            }
        }
        
        // Generate sample user data based on clusters
        function generateSampleUserData(clusters) {
            const sampleUsers = [];
            const learningStyles = ['visual', 'auditory', 'reading', 'kinesthetic'];
            const interests = ['Science', 'Technology', 'Art', 'Music', 'Sports', 'Cooking', 'Travel', 'Programming', 'Mathematics', 'History'];
            const analogyDomains = ['Gaming', 'Sports', 'Movies', 'Technology', 'Cooking', 'Everyday Life'];
            
            clusters.forEach((cluster, clusterIndex) => {
                // Generate users for this cluster based on member_count
                const numUsers = Math.max(cluster.member_count || 5, 3); // At least 3 users per cluster
                
                for (let i = 0; i < numUsers; i++) {
                    const userId = `user-${clusterIndex}-${i}`;
                    const centroid = cluster.centroid;
                    
                    // Generate user preferences based on cluster centroid with some variation
                    const technical_depth = Math.max(0, Math.min(100, 
                        (centroid.technical_depth * 100) + (Math.random() - 0.5) * 20));
                    
                    const visual_learning = Math.max(0, Math.min(100, 
                        (centroid.visual_learning * 100) + (Math.random() - 0.5) * 20));
                    
                    const practical_examples = Math.max(0, Math.min(100, 
                        (centroid.practical_examples * 100) + (Math.random() - 0.5) * 20));
                    
                    // Pick learning style based on cluster weights
                    const styleWeights = centroid.learning_style_weights || {};
                    const dominantStyle = Object.keys(styleWeights).reduce((a, b) => 
                        styleWeights[a] > styleWeights[b] ? a : b, 'visual');
                    
                    // Pick interests based on cluster interest weights
                    const interestWeights = centroid.interest_weights || {};
                    const topInterests = Object.keys(interestWeights)
                        .filter(key => interestWeights[key] > 0)
                        .slice(0, 3);
                    
                    const userInterests = topInterests.length > 0 ? 
                        topInterests.map(interest => interest.charAt(0).toUpperCase() + interest.slice(1)) :
                        interests.slice(0, 2 + Math.floor(Math.random() * 3));
                    
                    const user = {
                        id: userId,
                        username: `User ${clusterIndex + 1}-${i + 1}`,
                        cluster_id: cluster.id,
                        technical_depth: Math.round(technical_depth),
                        visual_learning: Math.round(visual_learning),
                        practical_examples: Math.round(practical_examples),
                        learning_style: dominantStyle,
                        age: 20 + Math.floor(Math.random() * 40),
                        education_level: ['high_school', 'undergraduate', 'graduate'][Math.floor(Math.random() * 3)],
                        occupation: ['student', 'professional', 'researcher'][Math.floor(Math.random() * 3)],
                        interests: userInterests,
                        preferred_analogy_domains: analogyDomains.slice(0, 2 + Math.floor(Math.random() * 2)),
                        avg_feedback_rating: 3 + Math.random() * 2, // 3-5 rating
                        feedback_count: Math.floor(Math.random() * 20),
                        main_learning_goal: 'Understanding complex concepts'
                    };
                    
                    sampleUsers.push(user);
                }
            });
            
            console.log(`Generated ${sampleUsers.length} sample users across ${clusters.length} clusters`);
            return sampleUsers;
        }
    </script>
</body>
</html> 