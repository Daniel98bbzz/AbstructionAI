<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crowd Wisdom System Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://unpkg.com/ml-matrix@6.10.4/ml-matrix.min.js"></script>
    <script src="crowd-wisdom-api.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Roboto, -apple-system, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .dashboard-header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px 0;
            color: white;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .dashboard-header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .dashboard-header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 30px;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto auto;
            gap: 25px;
            margin-bottom: 30px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .panel-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e6ed;
        }

        .panel-header h3 {
            font-size: 1.4rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .panel-header .icon {
            width: 24px;
            height: 24px;
            margin-right: 12px;
            opacity: 0.7;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        /* Step Flow Visualization */
        .step-flow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
        }

        .step {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            flex: 1;
        }

        .step-circle {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .step-1 { background: linear-gradient(135deg, #667eea, #764ba2); }
        .step-2 { background: linear-gradient(135deg, #f093fb, #f5576c); }
        .step-3 { background: linear-gradient(135deg, #4facfe, #00f2fe); }
        .step-4 { background: linear-gradient(135deg, #43e97b, #38f9d7); }
        .step-5 { background: linear-gradient(135deg, #fa709a, #fee140); }
        .step-6 { background: linear-gradient(135deg, #a8edea, #fed6e3); }

        .step-arrow {
            position: absolute;
            right: -20px;
            top: 20px;
            width: 0;
            height: 0;
            border-left: 15px solid #ddd;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
        }

        .step:last-child .step-arrow {
            display: none;
        }

        .step-title {
            font-weight: 600;
            text-align: center;
            font-size: 0.9rem;
            color: #2c3e50;
        }

        .step-description {
            font-size: 0.8rem;
            color: #7f8c8d;
            text-align: center;
            margin-top: 5px;
        }

        /* Embedding Visualization */
        .embedding-container {
            position: relative;
            height: 400px;
            overflow: hidden;
        }

        .cluster-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .cluster-node:hover {
            stroke-width: 3px;
            filter: drop-shadow(0 0 8px rgba(0,0,0,0.3));
        }

        .query-point {
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .query-point:hover {
            r: 8;
            stroke-width: 2px;
        }

        .similarity-line {
            stroke: #3498db;
            stroke-width: 2;
            opacity: 0.6;
            stroke-dasharray: 5,5;
            animation: dash 2s linear infinite;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -10;
            }
        }

        /* Learning Timeline */
        .timeline-container {
            height: 300px;
            position: relative;
        }

        .timeline-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .timeline-item.positive {
            border-left-color: #27ae60;
            background: #d5f4e6;
        }

        .timeline-item.negative {
            border-left-color: #e74c3c;
            background: #fadbd8;
        }

        .timeline-time {
            font-size: 0.8rem;
            color: #7f8c8d;
            min-width: 100px;
        }

        .timeline-content {
            flex: 1;
            margin-left: 15px;
        }

        .timeline-query {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .timeline-feedback {
            font-size: 0.9rem;
            color: #555;
        }

        /* Statistics Cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        /* Prompt Evolution */
        .prompt-evolution {
            max-height: 350px;
            overflow-y: auto;
        }

        .prompt-version {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e0e6ed;
        }

        .prompt-version.current {
            background: #e8f5e8;
            border-color: #27ae60;
        }

        .prompt-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 10px;
        }

        .version-badge {
            background: #3498db;
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .version-badge.current {
            background: #27ae60;
        }

        .prompt-text {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            max-height: 120px;
            overflow-y: auto;
        }

        /* Controls */
        .controls {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 25px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            color: white;
            font-weight: 500;
        }

        .control-group select,
        .control-group input {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb, #f5576c);
        }

        /* Real-time indicators */
        .live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #27ae60;
            font-weight: 500;
        }

        .live-dot {
            width: 8px;
            height: 8px;
            background: #27ae60;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        /* Tooltips */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 1000;
            max-width: 250px;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            
            .step-flow {
                flex-direction: column;
                gap: 20px;
            }
            
            .step-arrow {
                display: none;
            }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div class="dashboard-header">
        <h1>🧠 Crowd Wisdom System Dashboard</h1>
        <p>Real-time visualization of query clustering, feedback analysis, and collective learning</p>
    </div>

    <div class="container">
        <!-- Controls -->
        <div class="controls">
            <div class="control-group">
                <label for="timeRange">Time Range:</label>
                <select id="timeRange">
                    <option value="1h">Last Hour</option>
                    <option value="24h" selected>Last 24 Hours</option>
                    <option value="7d">Last 7 Days</option>
                    <option value="30d">Last 30 Days</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="clusterFilter">Cluster:</label>
                <select id="clusterFilter">
                    <option value="">All Clusters</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="similarityThreshold">Similarity Threshold:</label>
                <input type="range" id="similarityThreshold" min="0.1" max="1.0" step="0.1" value="0.6">
                <span id="thresholdValue">0.6</span>
            </div>
            
            <button class="btn" id="refreshData">🔄 Refresh Data</button>
            <button class="btn btn-secondary" id="liveMode">📡 Live Mode</button>
            
            <div class="live-indicator" id="liveIndicator" style="display: none;">
                <div class="live-dot"></div>
                Live Updates
            </div>
        </div>

        <!-- Main Dashboard Grid -->
        <div class="dashboard-grid">
            <!-- System Overview -->
            <div class="panel full-width">
                <div class="panel-header">
                    <span class="icon">🔄</span>
                    <h3>Crowd Wisdom Flow Overview</h3>
                </div>
                
                <div class="step-flow">
                    <div class="step">
                        <div class="step-circle step-1">1</div>
                        <div class="step-title">Embedding Creation</div>
                        <div class="step-description">Generate 1536D vector</div>
                        <div class="step-arrow"></div>
                    </div>
                    
                    <div class="step">
                        <div class="step-circle step-2">2</div>
                        <div class="step-title">Cluster Matching</div>
                        <div class="step-description">Cosine similarity > 0.6</div>
                        <div class="step-arrow"></div>
                    </div>
                    
                    <div class="step">
                        <div class="step-circle step-3">3</div>
                        <div class="step-title">Prompt Enhancement</div>
                        <div class="step-description">Apply learned patterns</div>
                        <div class="step-arrow"></div>
                    </div>
                    
                    <div class="step">
                        <div class="step-circle step-4">4</div>
                        <div class="step-title">Feedback Analysis</div>
                        <div class="step-description">Pattern + GPT analysis</div>
                        <div class="step-arrow"></div>
                    </div>
                    
                    <div class="step">
                        <div class="step-circle step-5">5</div>
                        <div class="step-title">Learning Trigger</div>
                        <div class="step-description">Extract success patterns</div>
                        <div class="step-arrow"></div>
                    </div>
                    
                    <div class="step">
                        <div class="step-circle step-6">6</div>
                        <div class="step-title">Knowledge Evolution</div>
                        <div class="step-description">Update cluster prompts</div>
                    </div>
                </div>
            </div>

            <!-- Embedding Space Visualization -->
            <div class="panel">
                <div class="panel-header">
                    <span class="icon">🎯</span>
                    <h3>Query Clustering Map</h3>
                </div>
                <div class="embedding-container" id="embeddingViz"></div>
            </div>

            <!-- Real-time Statistics -->
            <div class="panel">
                <div class="panel-header">
                    <span class="icon">📊</span>
                    <h3>System Statistics</h3>
                </div>
                <div class="stats-grid" id="statsGrid"></div>
                <div id="metricsChart" style="height: 200px;"></div>
            </div>

            <!-- Feedback & Learning Timeline -->
            <div class="panel">
                <div class="panel-header">
                    <span class="icon">🎓</span>
                    <h3>Learning Timeline</h3>
                </div>
                <div class="timeline-container" id="learningTimeline"></div>
            </div>

            <!-- Prompt Evolution -->
            <div class="panel">
                <div class="panel-header">
                    <span class="icon">📝</span>
                    <h3>Prompt Evolution</h3>
                </div>
                <div class="prompt-evolution" id="promptEvolution"></div>
            </div>
        </div>
    </div>

    <script>
        // Dashboard state
        let dashboardData = {
            clusters: [],
            queries: [],
            learningEvents: [],
            stats: {},
            isLiveMode: false,
            api: null,
            websocket: null
        };

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            initializeDashboard();
            loadInitialData();
            setupEventHandlers();
        });

        function initializeDashboard() {
            console.log('🚀 Initializing Crowd Wisdom Dashboard');
            
            // Initialize API connection
            dashboardData.api = new CrowdWisdomAPI();
            
            updateThresholdDisplay();
        }

        function setupEventHandlers() {
            // Threshold slider
            const slider = document.getElementById('similarityThreshold');
            slider.addEventListener('input', updateThresholdDisplay);
            
            // Refresh button
            document.getElementById('refreshData').addEventListener('click', loadInitialData);
            
            // Live mode toggle
            document.getElementById('liveMode').addEventListener('click', toggleLiveMode);
            
            // Time range filter
            document.getElementById('timeRange').addEventListener('change', loadInitialData);
            
            // Cluster filter
            document.getElementById('clusterFilter').addEventListener('change', filterByCluster);
        }

        function updateThresholdDisplay() {
            const value = document.getElementById('similarityThreshold').value;
            document.getElementById('thresholdValue').textContent = value;
        }

        function toggleLiveMode() {
            dashboardData.isLiveMode = !dashboardData.isLiveMode;
            const button = document.getElementById('liveMode');
            const indicator = document.getElementById('liveIndicator');
            
            if (dashboardData.isLiveMode) {
                button.textContent = '⏸️ Stop Live';
                indicator.style.display = 'flex';
                startLiveUpdates();
            } else {
                button.textContent = '📡 Live Mode';
                indicator.style.display = 'none';
                stopLiveUpdates();
            }
        }

        function startLiveUpdates() {
            // Connect to WebSocket for real-time updates
            try {
                dashboardData.websocket = dashboardData.api.connectWebSocket((data) => {
                    console.log('📡 Real-time update received:', data);
                    handleLiveUpdate(data);
                });
            } catch (error) {
                console.error('Failed to connect WebSocket:', error);
                // Fallback to polling
                dashboardData.liveInterval = setInterval(() => {
                    if (dashboardData.isLiveMode) {
                        loadInitialData();
                    }
                }, 10000);
            }
        }

        function stopLiveUpdates() {
            if (dashboardData.websocket) {
                dashboardData.websocket.close();
                dashboardData.websocket = null;
            }
            
            if (dashboardData.liveInterval) {
                clearInterval(dashboardData.liveInterval);
                dashboardData.liveInterval = null;
            }
        }

        function handleLiveUpdate(update) {
            const { type, data } = update;
            
            switch (type) {
                case 'new_query':
                    // Update query visualization
                    updateQueryVisualization(data);
                    break;
                case 'learning_event':
                    // Add to learning timeline
                    addToLearningTimeline(data);
                    break;
                case 'cluster_update':
                    // Update cluster data
                    updateClusterData(data);
                    break;
                case 'stats_update':
                    // Update statistics
                    updateStatistics(data);
                    break;
            }
        }

        async function loadInitialData() {
            console.log('📊 Loading dashboard data...');
            showLoadingState();
            
            try {
                const timeRange = document.getElementById('timeRange').value;
                const clusterId = document.getElementById('clusterFilter').value;
                
                // Load crowd wisdom data from existing API
                const [clustersResponse, statsResponse, learningResponse] = await Promise.all([
                    fetch(`http://localhost:3002/api/crowd-wisdom/clusters?limit=50`),
                    fetch(`http://localhost:3002/api/crowd-wisdom/stats?timeframe=${timeRange.replace('h', ' hours').replace('d', ' days')}`),
                    fetch(`http://localhost:3002/api/crowd-wisdom/learning-events?limit=50&timeframe=${timeRange.replace('h', ' hours').replace('d', ' days')}${clusterId ? `&clusterId=${clusterId}` : ''}`)
                ]);

                if (!clustersResponse.ok || !statsResponse.ok || !learningResponse.ok) {
                    throw new Error('Failed to fetch data from crowd wisdom API');
                }

                const clustersData = await clustersResponse.json();
                const statsData = await statsResponse.json();
                const learningData = await learningResponse.json();

                // Transform API data to dashboard format
                dashboardData.clusters = clustersData.success ? clustersData.data.map(cluster => ({
                    id: cluster.id,
                    cluster_name: cluster.name || cluster.representativeQuery,
                    representative_query: cluster.representativeQuery,
                    total_queries: cluster.totalQueries,
                    success_count: cluster.successCount,
                    success_rate: cluster.successRate,
                    prompt_enhancement: cluster.hasPromptEnhancement ? 'Enhanced prompt applied' : null,
                    centroid: [Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1], // Mock 3D coordinates
                    domain: identifyDomainFromQuery(cluster.representativeQuery)
                })) : [];

                dashboardData.stats = statsData.success ? {
                    totalClusters: clustersData.data?.length || 0,
                    totalQueries: statsData.data.totalQueries || 0,
                    avgSimilarity: 0.75, // Not available in current API
                    learningEvents: learningData.data?.length || 0,
                    successRate: statsData.data.successRate || 0,
                    avgConfidence: 0.85 // Not available in current API
                } : dashboardData.stats;

                dashboardData.learningEvents = learningData.success ? learningData.data.map(event => ({
                    id: event.id,
                    cluster_id: event.clusterId,
                    query: event.queryText || 'Learning event',
                    feedback: 'Positive learning detected',
                    confidence: event.confidenceScore || 0.8,
                    timestamp: new Date(event.createdAt),
                    isPositive: true,
                    patterns: extractPatternsFromEvent(event.extractedPatterns),
                    learningTrigger: event.learningTrigger
                })) : [];

                // Update all visualizations
                renderEmbeddingVisualization();
                renderStatistics();
                renderLearningTimeline();
                renderPromptEvolution();
                populateClusterFilter();
                
                hideLoadingState();

            } catch (error) {
                console.error('❌ Error loading dashboard data:', error);
                showErrorMessage('Failed to load dashboard data. Using mock data for demonstration.');
                
                // Fallback to mock data
                await loadMockData();
                hideLoadingState();
            }
        }

        // Helper function to identify domain from query text
        function identifyDomainFromQuery(query) {
            if (!query) return 'general';
            
            const queryLower = query.toLowerCase();
            const domains = {
                'computer science': ['algorithm', 'programming', 'software', 'computer', 'memory', 'cache', 'cpu', 'code'],
                'chemistry': ['chemical', 'bond', 'molecule', 'atom', 'reaction', 'element'],
                'geology': ['volcano', 'earthquake', 'rock', 'mineral', 'plate', 'earth'],
                'physics': ['force', 'energy', 'quantum', 'relativity', 'wave', 'particle'],
                'biology': ['cell', 'dna', 'organism', 'evolution', 'genetics', 'ecosystem'],
                'mathematics': ['equation', 'formula', 'math', 'calculate', 'algebra', 'geometry']
            };
            
            for (const [domain, keywords] of Object.entries(domains)) {
                if (keywords.some(keyword => queryLower.includes(keyword))) {
                    return domain;
                }
            }
            
            return 'general';
        }

        // Helper function to extract patterns from learning events
        function extractPatternsFromEvent(extractedPatterns) {
            if (!extractedPatterns) return [];
            
            try {
                if (typeof extractedPatterns === 'string') {
                    const parsed = JSON.parse(extractedPatterns);
                    return parsed.teachingTechniques || parsed.specificStrengths || parsed.patterns || [];
                }
                
                if (extractedPatterns.teachingTechniques) {
                    return extractedPatterns.teachingTechniques;
                }
                
                if (Array.isArray(extractedPatterns)) {
                    return extractedPatterns;
                }
                
                return [];
            } catch (error) {
                console.error('Error extracting patterns:', error);
                return [];
            }
        }

        function showLoadingState() {
            // Add loading indicators to all panels
            const panels = document.querySelectorAll('.panel');
            panels.forEach(panel => {
                const content = panel.querySelector('.panel-header').nextSibling;
                if (content) {
                    content.style.opacity = '0.5';
                }
            });
        }

        function hideLoadingState() {
            const panels = document.querySelectorAll('.panel');
            panels.forEach(panel => {
                const content = panel.querySelector('.panel-header').nextSibling;
                if (content) {
                    content.style.opacity = '1';
                }
            });
        }

        function filterByCluster() {
            const clusterId = document.getElementById('clusterFilter').value;
            const timeRange = document.getElementById('timeRange').value;
            
            if (clusterId) {
                // Load data for specific cluster
                dashboardData.api.getLearningEvents(timeRange, clusterId)
                    .then(learningData => {
                        dashboardData.learningEvents = learningData;
                        renderLearningTimeline();
                    })
                    .catch(error => {
                        console.error('Error filtering by cluster:', error);
                    });
            } else {
                // Load all data
                loadInitialData();
            }
        }

        function renderEmbeddingVisualization() {
            const container = document.getElementById('embeddingViz');
            container.innerHTML = '';

            const width = container.clientWidth;
            const height = 400;

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // Create scales for positioning (simplified 2D projection)
            const xScale = d3.scaleLinear()
                .domain([-1, 1])
                .range([50, width - 50]);

            const yScale = d3.scaleLinear()
                .domain([-1, 1])
                .range([height - 50, 50]);

            // Color scale for domains
            const colorScale = d3.scaleOrdinal()
                .domain(['computer science', 'chemistry', 'geology', 'physics', 'biology', 'general'])
                .range(['#667eea', '#f093fb', '#43e97b', '#fa709a', '#4facfe', '#a8edea']);

            // Draw clusters
            const clusters = svg.selectAll('.cluster-node')
                .data(dashboardData.clusters)
                .enter()
                .append('g')
                .attr('class', 'cluster-node')
                .attr('transform', d => `translate(${xScale(d.centroid[0])}, ${yScale(d.centroid[1])})`);

            // Cluster circles
            clusters.append('circle')
                .attr('r', d => Math.max(15, 10 + d.total_queries * 1.5))
                .attr('fill', d => colorScale(d.domain))
                .attr('opacity', 0.7)
                .attr('stroke', '#fff')
                .attr('stroke-width', 2);

            // Cluster labels
            clusters.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', 5)
                .attr('fill', 'white')
                .attr('font-weight', 'bold')
                .attr('font-size', '12px')
                .text(d => d.total_queries);

            // Add cluster names on hover
            clusters.append('title')
                .text(d => `${d.cluster_name || d.name}\nQueries: ${d.total_queries}\nSuccess Rate: ${(d.success_rate * 100).toFixed(1)}%\nDomain: ${d.domain}`);

            // Add click handler for cluster details
            clusters.on('click', function(event, d) {
                showClusterDetails(d);
            });

            // Simulate new query (for visualization purposes)
            if (dashboardData.clusters.length > 0) {
                const newQuery = { x: 0.3, y: 0.7, similarity: 0.8, targetCluster: dashboardData.clusters[0].id };
                
                // Draw new query point
                svg.append('circle')
                    .attr('class', 'query-point')
                    .attr('cx', xScale(newQuery.x))
                    .attr('cy', yScale(newQuery.y))
                    .attr('r', 6)
                    .attr('fill', '#e74c3c')
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 2)
                    .append('title')
                    .text('New incoming query');

                // Draw similarity line to closest cluster
                const targetCluster = dashboardData.clusters[0];
                if (targetCluster) {
                    svg.append('line')
                        .attr('class', 'similarity-line')
                        .attr('x1', xScale(newQuery.x))
                        .attr('y1', yScale(newQuery.y))
                        .attr('x2', xScale(targetCluster.centroid[0]))
                        .attr('y2', yScale(targetCluster.centroid[1]));

                    // Add similarity label
                    svg.append('text')
                        .attr('x', (xScale(newQuery.x) + xScale(targetCluster.centroid[0])) / 2)
                        .attr('y', (yScale(newQuery.y) + yScale(targetCluster.centroid[1])) / 2 - 10)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#3498db')
                        .attr('font-size', '12px')
                        .attr('font-weight', 'bold')
                        .text(`${(newQuery.similarity * 100).toFixed(0)}%`);
                }
            }

            // Add legend
            const legend = svg.append('g')
                .attr('transform', `translate(10, 10)`);

            const uniqueDomains = [...new Set(dashboardData.clusters.map(c => c.domain))];
            uniqueDomains.forEach((domain, i) => {
                const legendItem = legend.append('g')
                    .attr('transform', `translate(0, ${i * 20})`);
                
                legendItem.append('circle')
                    .attr('r', 6)
                    .attr('fill', colorScale(domain));
                
                legendItem.append('text')
                    .attr('x', 15)
                    .attr('y', 5)
                    .attr('font-size', '12px')
                    .text(domain);
            });
        }

        function showClusterDetails(cluster) {
            // Display detailed cluster information
            alert(`Cluster: ${cluster.cluster_name || cluster.name}\n` +
                  `Representative Query: ${cluster.representative_query}\n` +
                  `Total Queries: ${cluster.total_queries}\n` +
                  `Success Rate: ${(cluster.success_rate * 100).toFixed(1)}%\n` +
                  `Domain: ${cluster.domain}\n` +
                  `Has Enhancement: ${cluster.prompt_enhancement ? 'Yes' : 'No'}`);
        }

        function renderStatistics() {
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = '';

            const stats = [
                { label: 'Total Clusters', value: dashboardData.stats.totalClusters, color: '#667eea' },
                { label: 'Total Queries', value: dashboardData.stats.totalQueries, color: '#f093fb' },
                { label: 'Avg Similarity', value: (dashboardData.stats.avgSimilarity * 100).toFixed(1) + '%', color: '#43e97b' },
                { label: 'Learning Events', value: dashboardData.stats.learningEvents, color: '#fa709a' },
                { label: 'Success Rate', value: (dashboardData.stats.successRate * 100).toFixed(1) + '%', color: '#4facfe' },
                { label: 'Avg Confidence', value: (dashboardData.stats.avgConfidence * 100).toFixed(1) + '%', color: '#a8edea' }
            ];

            stats.forEach(stat => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.style.background = `linear-gradient(135deg, ${stat.color}, ${stat.color}dd)`;
                card.innerHTML = `
                    <div class="stat-value">${stat.value}</div>
                    <div class="stat-label">${stat.label}</div>
                `;
                statsGrid.appendChild(card);
            });

            // Render metrics chart
            renderMetricsChart();
        }

        function renderMetricsChart() {
            // Generate sample time series data (in real implementation, this would come from API)
            const now = Date.now();
            const data = [];
            for (let i = 23; i >= 0; i--) {
                data.push({
                    time: new Date(now - i * 3600000),
                    queries: Math.floor(Math.random() * 10) + 5,
                    learning: Math.floor(Math.random() * 3),
                    success_rate: 0.6 + Math.random() * 0.3
                });
            }

            const trace1 = {
                x: data.map(d => d.time),
                y: data.map(d => d.queries),
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Queries/Hour',
                line: { color: '#667eea' }
            };

            const trace2 = {
                x: data.map(d => d.time),
                y: data.map(d => d.learning),
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Learning Events',
                yaxis: 'y2',
                line: { color: '#f093fb' }
            };

            const layout = {
                title: 'System Activity (24h)',
                xaxis: { title: 'Time' },
                yaxis: { title: 'Queries', side: 'left' },
                yaxis2: { title: 'Learning Events', side: 'right', overlaying: 'y' },
                margin: { l: 50, r: 50, t: 50, b: 50 },
                height: 200,
                showlegend: false
            };

            Plotly.newPlot('metricsChart', [trace1, trace2], layout, { responsive: true });
        }

        function renderLearningTimeline() {
            const timeline = document.getElementById('learningTimeline');
            timeline.innerHTML = '';

            if (dashboardData.learningEvents.length === 0) {
                timeline.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No learning events in selected timeframe</p>';
                return;
            }

            dashboardData.learningEvents.forEach(event => {
                const item = document.createElement('div');
                item.className = `timeline-item ${event.isPositive ? 'positive' : 'negative'}`;
                
                const timeStr = new Date(event.timestamp).toLocaleTimeString();
                const cluster = dashboardData.clusters.find(c => c.id === event.cluster_id);
                
                item.innerHTML = `
                    <div class="timeline-time">${timeStr}</div>
                    <div class="timeline-content">
                        <div class="timeline-query">${event.query}</div>
                        <div class="timeline-feedback">
                            "${event.feedback}" 
                            <strong>(${(event.confidence * 100).toFixed(0)}% confidence)</strong>
                        </div>
                        ${event.patterns && event.patterns.length > 0 ? `<div style="margin-top: 8px; font-size: 0.8rem; color: #666;">
                            Patterns: ${event.patterns.join(', ')}
                        </div>` : ''}
                        ${cluster ? `<div style="margin-top: 5px; font-size: 0.8rem; color: #999;">
                            Cluster: ${cluster.cluster_name || cluster.name}
                        </div>` : ''}
                    </div>
                `;
                
                timeline.appendChild(item);
            });
        }

        function renderPromptEvolution() {
            const container = document.getElementById('promptEvolution');
            container.innerHTML = '';

            const clustersWithEnhancements = dashboardData.clusters.filter(c => c.prompt_enhancement);

            if (clustersWithEnhancements.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No prompt enhancements available yet</p>';
                return;
            }

            // Show prompt evolution for each cluster
            clustersWithEnhancements.forEach((cluster, index) => {
                const promptDiv = document.createElement('div');
                promptDiv.className = `prompt-version ${index === 0 ? 'current' : ''}`;
                
                promptDiv.innerHTML = `
                    <div class="prompt-header">
                        <h4>${cluster.cluster_name || cluster.name}</h4>
                        <span class="version-badge ${index === 0 ? 'current' : ''}">
                            ${index === 0 ? 'Current' : `v1.${index}`}
                        </span>
                    </div>
                    <div class="prompt-text">${cluster.prompt_enhancement}</div>
                    <div style="margin-top: 10px; font-size: 0.8rem; color: #666;">
                        Success Rate: ${(cluster.success_rate * 100).toFixed(1)}% | 
                        Total Queries: ${cluster.total_queries} |
                        Domain: ${cluster.domain}
                    </div>
                `;
                
                container.appendChild(promptDiv);
            });
        }

        function populateClusterFilter() {
            const select = document.getElementById('clusterFilter');
            select.innerHTML = '<option value="">All Clusters</option>';
            
            dashboardData.clusters.forEach(cluster => {
                const option = document.createElement('option');
                option.value = cluster.id;
                option.textContent = cluster.cluster_name || cluster.name;
                select.appendChild(option);
            });
        }

        function showErrorMessage(message) {
            console.error(message);
            
            // Create a more user-friendly error display
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #ff4757;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 1000;
                max-width: 300px;
            `;
            errorDiv.innerHTML = `
                <strong>⚠️ Connection Error</strong><br>
                ${message}
                <button onclick="this.parentElement.remove()" style="
                    float: right;
                    background: none;
                    border: none;
                    color: white;
                    font-size: 16px;
                    cursor: pointer;
                    margin-left: 10px;
                ">×</button>
            `;
            
            document.body.appendChild(errorDiv);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (errorDiv.parentElement) {
                    errorDiv.remove();
                }
            }, 5000);
        }

        // Functions for real-time updates
        function updateQueryVisualization(queryData) {
            // Add animation for new query appearing
            console.log('🎯 New query visualization update:', queryData);
            // Re-render embedding visualization with new query
            renderEmbeddingVisualization();
        }

        function addToLearningTimeline(learningData) {
            console.log('🎓 New learning event:', learningData);
            // Add new learning event to timeline
            dashboardData.learningEvents.unshift(learningData);
            renderLearningTimeline();
        }

        function updateClusterData(clusterData) {
            console.log('🔄 Cluster update:', clusterData);
            // Update specific cluster data
            const clusterIndex = dashboardData.clusters.findIndex(c => c.id === clusterData.id);
            if (clusterIndex !== -1) {
                dashboardData.clusters[clusterIndex] = { ...dashboardData.clusters[clusterIndex], ...clusterData };
                renderEmbeddingVisualization();
                renderPromptEvolution();
            }
        }

        function updateStatistics(statsData) {
            console.log('📊 Statistics update:', statsData);
            // Update dashboard statistics
            dashboardData.stats = { ...dashboardData.stats, ...statsData };
            renderStatistics();
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            stopLiveUpdates();
        });

        async function loadMockData() {
            // Keep the original mock data loading as fallback
            dashboardData.clusters = [
                {
                    id: 'cluster-1',
                    cluster_name: 'Memory Hierarchy Queries',
                    representative_query: 'How does memory hierarchy work?',
                    total_queries: 12,
                    success_count: 8,
                    success_rate: 0.67,
                    prompt_enhancement: 'Use hierarchical breakdown to organize information logically...',
                    centroid: [0.2, 0.8, -0.3],
                    domain: 'computer science'
                },
                {
                    id: 'cluster-2', 
                    cluster_name: 'Chemical Bonds Queries',
                    representative_query: 'What are chemical bonds?',
                    total_queries: 18,
                    success_count: 14,
                    success_rate: 0.78,
                    prompt_enhancement: 'Begin with fundamental concepts, use analogies...',
                    centroid: [-0.4, 0.1, 0.6],
                    domain: 'chemistry'
                },
                {
                    id: 'cluster-3',
                    cluster_name: 'Volcano Formation Queries', 
                    representative_query: 'How do volcanoes form?',
                    total_queries: 6,
                    success_count: 4,
                    success_rate: 0.67,
                    prompt_enhancement: 'Use structured approach with clear headings...',
                    centroid: [0.6, -0.2, 0.1],
                    domain: 'geology'
                }
            ];

            dashboardData.stats = {
                totalClusters: 16,
                totalQueries: 142,
                avgSimilarity: 0.73,
                learningEvents: 23,
                successRate: 0.71,
                avgConfidence: 0.82
            };

            dashboardData.learningEvents = [
                {
                    id: 'learn-1',
                    cluster_id: 'cluster-1',
                    query: 'Explain memory hierarchy in detail',
                    feedback: 'This was really helpful and clear!',
                    confidence: 0.95,
                    timestamp: new Date(Date.now() - 3600000),
                    isPositive: true,
                    patterns: ['step-by-step', 'clear structure', 'good examples']
                },
                {
                    id: 'learn-2',
                    cluster_id: 'cluster-2',
                    query: 'What are ionic bonds?',
                    feedback: 'Perfect explanation with great analogies',
                    confidence: 0.92,
                    timestamp: new Date(Date.now() - 7200000),
                    isPositive: true,
                    patterns: ['analogies', 'conceptual connections']
                }
            ];

            // Update visualizations with mock data
            renderEmbeddingVisualization();
            renderStatistics();
            renderLearningTimeline();
            renderPromptEvolution();
            populateClusterFilter();
        }
    </script>
</body>
</html> 